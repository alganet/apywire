{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#apywire-documentation","title":"apywire Documentation","text":"<p>Welcome to the apywire documentation! apywire is a powerful, flexible dependency injection library for Python 3.12+ that makes managing object dependencies simple and elegant.</p>"},{"location":"#what-is-apywire","title":"What is apywire?","text":"<p>apywire provides lazy object wiring through a clean, declarative specification format. Instead of manually instantiating objects and passing dependencies around, you define a <code>spec</code> that describes what you need, and apywire handles the rest.</p> <pre><code>from apywire import Wiring\n\n# Define what you want\nspec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n    \"MyService service\": {\"start_time\": \"{now}\"},  # Reference other objects\n}\n\n# Get what you need\nwired = Wiring(spec)\nservice = wired.service()  # Dependencies resolved automatically\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#lazy-loading","title":"\ud83d\ude80 Lazy Loading","text":"<p>Objects are instantiated only when accessed, not when you create the container. This improves startup performance and lets you define everything upfront without overhead.</p>"},{"location":"#async-support","title":"\u26a1 Async Support","text":"<p>Built-in <code>async/await</code> support via <code>AioAccessor</code>. Use <code>await wired.aio.my_object()</code> for asynchronous object access without blocking the event loop.</p>"},{"location":"#thread-safety","title":"\ud83d\udd12 Thread Safety","text":"<p>Optional thread-safe instantiation using optimistic locking. Enable with <code>thread_safe=True</code> for multi-threaded applications.</p>"},{"location":"#code-generation","title":"\ud83d\udce6 Code Generation","text":"<p>Compile your specs to standalone Python code with <code>WiringCompiler(spec).compile()</code>. Deploy generated code for better performance and simpler dependency management.</p>"},{"location":"#naturally-configurable","title":"\ud83d\udcc4 Naturally Configurable","text":"<p>Load specs from YAML, TOML, JSON, or INI files. Keep configuration separate from code, support multiple environments, and let non-developers manage settings. Constants can reference other constants using <code>{name}</code> placeholders for flexible configuration.</p>"},{"location":"#zero-dependencies","title":"\ud83c\udfaf Zero Dependencies","text":"<p>No external runtime dependencies. apywire works with just Python 3.12+ standard library.</p>"},{"location":"#why-choose-apywire","title":"Why Choose apywire?","text":""},{"location":"#clean-declarative-configuration","title":"Clean, Declarative Configuration","text":"<p>Define your entire dependency graph in a single, readable dictionary. No decorators, no magic imports, just plain Python data structures.</p>"},{"location":"#perfect-for-layered-architectures","title":"Perfect for Layered Architectures","text":"<p>Ideal for applications with clear separation of concerns: database layer, service layer, API layer. Wire them together without tight coupling.</p>"},{"location":"#flexible-deployment-options","title":"Flexible Deployment Options","text":"<ul> <li>Development: Use runtime <code>Wiring</code> for fast iteration</li> <li>Production: Compile to standalone code for deployment</li> <li>Testing: Easily swap real dependencies for mocks</li> <li>Configuration: Load specs from YAML, TOML, JSON, or INI files</li> </ul>"},{"location":"#production-ready","title":"Production-Ready","text":"<ul> <li>Strict mypy type checking throughout</li> <li>95% test coverage or higher enforced</li> <li>Support for async, threading, and edge cases</li> <li>No external dependencies to manage</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Web Applications: FastAPI, Flask, Django services</li> <li>Microservices: Service-to-service communication setup</li> <li>CLI Tools: Complex command-line applications with many dependencies</li> <li>Data Pipelines: ETL processes with configurable components</li> <li>Testing: Mock injection for comprehensive test coverage</li> </ul>"},{"location":"#dependency-injection-via-placeholders","title":"Dependency Injection via Placeholders","text":"<p>Reference other wired objects using <code>{name}</code> placeholders:</p> <pre><code>spec = {\n    \"datetime.datetime base_time\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n    \"datetime.timedelta offset\": {\"days\": 7},\n    \"MyClass processor\": {\n        \"start_time\": \"{base_time}\",\n        \"delta\": \"{offset}\",\n    },\n}\n</code></pre>"},{"location":"#async-support_1","title":"Async Support","text":"<p>Access objects asynchronously in async contexts:</p> <pre><code>async def main():\n    wired = Wiring(spec)\n    obj = await wired.aio.my_object()  # Async access\n</code></pre>"},{"location":"#thread-safe-instantiation","title":"Thread-Safe Instantiation","text":"<p>Enable thread safety for multi-threaded applications:</p> <pre><code>wired = Wiring(spec, thread_safe=True)\n# Safe to use across multiple threads\n</code></pre>"},{"location":"#code-compilation","title":"Code Compilation","text":"<p>Generate standalone Python code from your wiring spec:</p> <pre><code>from apywire import WiringCompiler\n\ncompiler = WiringCompiler(spec)\ncode = compiler.compile(aio=True, thread_safe=True)\n# Returns Python code that behaves identically to the runtime container\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Detailed installation and setup guide</li> <li>User Guide - Comprehensive usage documentation</li> <li>API Reference - Complete API documentation</li> <li>Examples - Practical use cases and patterns</li> <li>Development - Contributing guide for developers</li> </ul>"},{"location":"#license","title":"License","text":"<p>apywire is licensed under the ISC License. See the LICENSE file for details.</p>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#api-reference","title":"API Reference","text":"<p>Comprehensive API documentation for apywire.</p>"},{"location":"api-reference/#core-classes","title":"Core Classes","text":""},{"location":"api-reference/#wiring","title":"Wiring","text":""},{"location":"api-reference/#apywire.Wiring","title":"Wiring  <code>module-attribute</code>","text":"<pre><code>Wiring = WiringRuntime\n</code></pre>"},{"location":"api-reference/#wiringruntime","title":"WiringRuntime","text":""},{"location":"api-reference/#apywire.WiringRuntime","title":"WiringRuntime","text":"<p>               Bases: <code>WiringBase</code>, <code>ThreadSafeMixin</code></p> <p>Runtime container for wired objects.</p> <p>This class handles the runtime resolution and instantiation of wired objects. It does NOT support compilation; use <code>WiringCompiler</code> for that.</p>"},{"location":"api-reference/#apywire.WiringRuntime.aio","title":"aio  <code>cached</code> <code>property</code>","text":"<pre><code>aio: 'AioAccessor'\n</code></pre> <p>Return a wrapper object providing async accessors.</p> <p>Use <code>await wired.aio.name()</code> to obtain the instantiated value asynchronously. We use <code>aio</code> to avoid the reserved keyword <code>async</code> (so <code>wired.async</code> would be invalid syntax).</p>"},{"location":"api-reference/#apywire.WiringRuntime.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Accessor\n</code></pre> <p>Return a callable accessor for the named wired object.</p>"},{"location":"api-reference/#apywire.WiringRuntime.__init__","title":"__init__","text":"<pre><code>__init__(\n    spec: Spec,\n    *,\n    thread_safe: bool = False,\n    max_lock_attempts: int = 10,\n    lock_retry_sleep: float = 0.01\n) -&gt; None\n</code></pre> <p>Initialize a WiringRuntime container.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>Spec</code> <p>The wiring spec mapping.</p> required <code>thread_safe</code> <code>bool</code> <p>Enable thread-safe instantiation (default: False).</p> <code>False</code> <code>max_lock_attempts</code> <code>int</code> <p>Max retries in global lock mode                (only when thread_safe=True).</p> <code>10</code> <code>lock_retry_sleep</code> <code>float</code> <p>Sleep time in seconds between lock retries                (only when thread_safe=True).</p> <code>0.01</code>"},{"location":"api-reference/#wiringcompiler","title":"WiringCompiler","text":""},{"location":"api-reference/#apywire.WiringCompiler","title":"WiringCompiler","text":"<p>               Bases: <code>WiringBase</code></p> <p>Wiring container with compilation support.</p>"},{"location":"api-reference/#apywire.WiringCompiler.compile","title":"compile","text":"<pre><code>compile(\n    *, aio: bool = False, thread_safe: bool = False\n) -&gt; str\n</code></pre> <p>Compiles the Spec into a string containing Python code.</p> <p>Parameters:</p> Name Type Description Default <code>aio</code> <code>bool</code> <p>If True, generate <code>async def</code> accessors for wired attributes that await referenced attributes and call blocking constructors in a threadpool via <code>asyncio.get_running_loop().run_in_executor</code>. When False (default) generate synchronous <code>def</code> accessors.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the Python source for the compiled</p> <code>str</code> <p><code>Compiled</code> container.</p>"},{"location":"api-reference/#wiringbase","title":"WiringBase","text":""},{"location":"api-reference/#apywire.WiringBase","title":"WiringBase","text":"<p>Base class for wiring containers.</p>"},{"location":"api-reference/#apywire.WiringBase.__annotations__","title":"__annotations__  <code>class-attribute</code>","text":"<pre><code>__annotations__ = {\n    \"_parsed\": \"dict[str, _ParsedEntry]\",\n    \"_values\": \"dict[str, _RuntimeValue]\",\n}\n</code></pre> <p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)</p>"},{"location":"api-reference/#apywire.WiringBase.__dict__","title":"__dict__  <code>class-attribute</code>","text":"<pre><code>__dict__ = mappingproxy({'__module__': 'apywire.wiring', '__doc__': 'Base class for wiring containers.', '__annotations__': {'_parsed': 'dict[str, _ParsedEntry]', '_values': 'dict[str, _RuntimeValue]'}, '__init__': &lt;cyfunction WiringBase.__init__ at 0x7f799a644ae0&gt;, '_parse_spec_entry': &lt;cyfunction WiringBase._parse_spec_entry at 0x7f799a644a10&gt;, '_is_placeholder': &lt;cyfunction WiringBase._is_placeholder at 0x7f799a644c80&gt;, '_extract_placeholder_name': &lt;cyfunction WiringBase._extract_placeholder_name at 0x7f799a644d50&gt;, '_resolve': &lt;cyfunction WiringBase._resolve at 0x7f799a644e20&gt;, '_interpolate_placeholders': &lt;cyfunction WiringBase._interpolate_placeholders at 0x7f799a644ef0&gt;, '_find_placeholder_names': &lt;cyfunction WiringBase._find_placeholder_names at 0x7f799a644fc0&gt;, '_topological_sort': &lt;cyfunction WiringBase._topological_sort at 0x7f799a644bb0&gt;, '_resolve_constant': &lt;cyfunction WiringBase._resolve_constant at 0x7f799a645090&gt;, '__dict__': &lt;attribute '__dict__' of 'WiringBase' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'WiringBase' objects&gt;})\n</code></pre> <p>Read-only proxy of a mapping.</p>"},{"location":"api-reference/#apywire.WiringBase.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Base class for wiring containers.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"api-reference/#apywire.WiringBase.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'apywire.wiring'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"api-reference/#apywire.WiringBase.__weakref__","title":"__weakref__  <code>property</code>","text":"<pre><code>__weakref__\n</code></pre> <p>list of weak references to the object</p>"},{"location":"api-reference/#apywire.WiringBase.__init__","title":"__init__  <code>method descriptor</code>","text":"<pre><code>__init__(\n    spec: dict,\n    *,\n    thread_safe: bool = False,\n    max_lock_attempts: int = 10,\n    lock_retry_sleep: float = 0.01\n) -&gt; None\n</code></pre> <p>Initialize a Wiring container.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict</code> <p>The wiring spec mapping.</p> required <code>thread_safe</code> <code>bool</code> <p>Enable thread-safe instantiation (default: False).</p> <code>False</code> <code>max_lock_attempts</code> <code>int</code> <p>Max retries in global lock mode                (only when thread_safe=True).</p> <code>10</code> <code>lock_retry_sleep</code> <code>float</code> <p>Sleep time in seconds between lock retries               (only when thread_safe=True).</p> <code>0.01</code>"},{"location":"api-reference/#generator","title":"Generator","text":""},{"location":"api-reference/#apywire.Generator","title":"Generator","text":"<p>Generates apywire specs from class introspection.</p> <p>This class inspects class constructors to automatically generate spec dictionaries with type-appropriate default values and placeholder references.</p> Example <p>spec = Generator.generate(\"datetime.datetime now\")</p>"},{"location":"api-reference/#apywire.Generator--returns-spec-with-now_year-now_month-now_day-etc","title":"Returns spec with now_year, now_month, now_day, etc.","text":""},{"location":"api-reference/#apywire.Generator.generate","title":"generate  <code>classmethod</code>","text":"<pre><code>generate(*entries: str) -&gt; Spec\n</code></pre> <p>Generate a spec from one or more class entry strings.</p> <p>Parameters:</p> Name Type Description Default <code>*entries</code> <code>str</code> <p>Entry strings in format \"module.Class name\" or       \"module.Class name.factoryMethod\"</p> <code>()</code> <p>Returns:</p> Type Description <code>Spec</code> <p>A spec dictionary suitable for use with apywire.Wiring</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If entry format is invalid</p> <code>CircularWiringError</code> <p>If circular dependencies detected</p> Example <p>spec = Generator.generate(\"datetime.datetime now\") wired = Wiring(spec)</p>"},{"location":"api-reference/#accessor-types","title":"Accessor Types","text":""},{"location":"api-reference/#accessor","title":"Accessor","text":""},{"location":"api-reference/#apywire.Accessor","title":"Accessor","text":"<p>A callable object that retrieves a wired value.</p>"},{"location":"api-reference/#apywire.Accessor.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; object\n</code></pre> <p>Return the wired object, instantiating it if necessary.</p>"},{"location":"api-reference/#aioaccessor","title":"AioAccessor","text":""},{"location":"api-reference/#apywire.AioAccessor","title":"AioAccessor","text":"<p>Helper for accessing wired objects asynchronously.</p>"},{"location":"api-reference/#apywire.AioAccessor.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Callable[[], Awaitable[object]]\n</code></pre> <p>Return an async callable for the named wired object.</p>"},{"location":"api-reference/#type-aliases","title":"Type Aliases","text":""},{"location":"api-reference/#spec","title":"Spec","text":"<pre><code>from apywire import Spec\n\nSpec = dict[str, dict[str | int, Any] | list[Any] | ConstantValue]\n</code></pre> <p>The <code>Spec</code> type represents the wiring specification dictionary. It maps wiring keys to configuration:</p> <ul> <li>Wiring keys with format <code>\"module.Class name\"</code> define objects to be wired</li> <li>Simple keys without a class become constants</li> <li>Values can be dictionaries (keyword args), lists (positional args), or constants</li> </ul> <p>Example:</p> <pre><code>from apywire import Spec\n\nspec: Spec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n    \"pathlib.Path root\": [\"/home/user\"],\n    \"port\": 8080,  # Constant\n}\n</code></pre>"},{"location":"api-reference/#specentry","title":"SpecEntry","text":"<pre><code>from apywire import SpecEntry\n\nSpecEntry = dict[str | int, Any]\n</code></pre> <p>The <code>SpecEntry</code> type represents a single entry in the spec (the configuration for one wired object):</p> <pre><code>from apywire import SpecEntry\n\nentry: SpecEntry = {\n    \"year\": 2025,\n    \"month\": 1,\n    \"day\": 1,\n}\n</code></pre>"},{"location":"api-reference/#exception-classes","title":"Exception Classes","text":""},{"location":"api-reference/#wiringerror","title":"WiringError","text":"<p>Base exception class for all apywire errors.</p>"},{"location":"api-reference/#apywire.WiringError","title":"WiringError","text":"<p>               Bases: <code>AttributeError</code></p> <p>Raised when the wiring system cannot instantiate an attribute.</p> <p>This wraps the underlying exception to provide context on which attribute failed to instantiate, while preserving the original exception as the cause.</p>"},{"location":"api-reference/#circularwiringerror","title":"CircularWiringError","text":"<p>Raised when a circular dependency is detected:</p> <pre><code>from apywire import CircularWiringError, Wiring\n\nspec = {\n    \"MyClass a\": {\"dep\": \"{b}\"},\n    \"MyClass b\": {\"dep\": \"{a}\"},\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.a()\nexcept CircularWiringError as e:\n    print(f\"Circular dependency: {e}\")\n</code></pre>"},{"location":"api-reference/#apywire.CircularWiringError","title":"CircularWiringError","text":"<p>               Bases: <code>WiringError</code></p> <p>Raised when a circular wiring dependency is detected.</p> <p>This class is a <code>WiringError</code> subtype for simpler programmatic handling of wiring-specific failures.</p>"},{"location":"api-reference/#unknownplaceholdererror","title":"UnknownPlaceholderError","text":"<p>Raised when a placeholder references a non-existent object:</p> <pre><code>from apywire import UnknownPlaceholderError, Wiring\n\nspec = {\n    \"MyClass obj\": {\"dep\": \"{nonexistent}\"},\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.obj()\nexcept UnknownPlaceholderError as e:\n    print(f\"Unknown placeholder: {e}\")\n</code></pre>"},{"location":"api-reference/#apywire.UnknownPlaceholderError","title":"UnknownPlaceholderError","text":"<p>               Bases: <code>WiringError</code></p> <p>Raised by <code>_resolve_runtime</code> when a placeholder name is not found in either constants (<code>_values</code>) or parsed spec entries (<code>_parsed</code>).</p>"},{"location":"api-reference/#lockunavailableerror","title":"LockUnavailableError","text":"<p>Raised in thread-safe mode when a lock cannot be acquired after maximum retry attempts:</p> <pre><code>from apywire import LockUnavailableError, Wiring\n\nwired = Wiring(spec, thread_safe=True, max_lock_attempts=1)\n\ntry:\n    obj = wired.my_object()\nexcept LockUnavailableError as e:\n    print(f\"Could not acquire lock: {e}\")\n</code></pre>"},{"location":"api-reference/#apywire.LockUnavailableError","title":"LockUnavailableError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Exception raised when a per-attribute lock cannot be acquired in optimistic (non-blocking) mode and the code must fall back to a global lock.</p> <p>This exception is used internally by the thread-safety system but is also referenced in compiled code, so it is part of the public API.</p>"},{"location":"api-reference/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/#basic-wiring","title":"Basic Wiring","text":"<pre><code>from apywire import Wiring\n\nspec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\nwired = Wiring(spec)\ndt = wired.now()  # datetime.datetime(2025, 1, 1, 0, 0)\n</code></pre>"},{"location":"api-reference/#async-access","title":"Async Access","text":"<pre><code>import asyncio\nfrom apywire import Wiring\n\nasync def main():\n    wired = Wiring(spec)\n    obj = await wired.aio.my_object()\n\nasyncio.run(main())\n</code></pre>"},{"location":"api-reference/#thread-safe-instantiation","title":"Thread-Safe Instantiation","text":"<pre><code>from apywire import Wiring\n\nwired = Wiring(spec, thread_safe=True)\n# Safe to use across multiple threads\n</code></pre>"},{"location":"api-reference/#code-compilation","title":"Code Compilation","text":"<pre><code>from apywire import WiringCompiler\n\ncompiler = WiringCompiler(spec)\ncode = compiler.compile(aio=True, thread_safe=True)\n\nwith open(\"compiled_wiring.py\", \"w\") as f:\n    f.write(code)\n</code></pre>"},{"location":"api-reference/#generator-spec-generator","title":"Generator (Spec Generator)","text":"<pre><code>from apywire import Generator, Wiring\n\n# Generate a spec from a class signature\nspec = Generator.generate(\"myapp.models.Simple now\")\n\n# Override a generated default if needed\nspec[\"now_year\"] = 2025\n\nwired = Wiring(spec)\nnow = wired.now()\n</code></pre>"},{"location":"api-reference/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Quick start guide</li> <li>User Guide - Comprehensive usage documentation</li> <li>Examples - Practical examples and patterns</li> </ul>"},{"location":"development/","title":"Development","text":""},{"location":"development/#development","title":"Development","text":"<p>Contributing guide for apywire developers.</p>"},{"location":"development/#getting-started","title":"Getting Started","text":""},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or later</li> <li>Git</li> <li>Make (optional but recommended)</li> </ul>"},{"location":"development/#initial-setup","title":"Initial Setup","text":"<p>Clone the repository and set up your development environment:</p> <pre><code>git clone https://github.com/alganet/apywire.git\ncd apywire\n\n# Create virtual environment and install dependencies\nmake .venv\nsource .venv/bin/activate\nmake pip\n</code></pre> <p>This will: 1. Create a <code>.venv</code> virtual environment 2. Install all development dependencies including mkdocs, pytest, mypy, etc.</p>"},{"location":"development/#development-workflow","title":"Development Workflow","text":""},{"location":"development/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests with pytest\nmake test\n\n# Run tests with coverage\nmake coverage\n\n# Run verbose tests\npytest -xvs\n</code></pre> <p>The project enforces 95% test coverage or higher. New code should include comprehensive tests.</p>"},{"location":"development/#code-formatting","title":"Code Formatting","text":"<p>The project uses <code>black</code> and <code>isort</code> for code formatting:</p> <pre><code># Format all code\nmake format\n</code></pre> <p>This command: 1. Runs <code>reuse annotate</code> to add SPDX headers 2. Formats code with <code>black</code> (79-character line length) 3. Sorts imports with <code>isort</code></p>"},{"location":"development/#linting","title":"Linting","text":"<pre><code># Run all linters\nmake lint\n</code></pre> <p>This runs: 1. <code>reuse lint</code> - Validates SPDX licensing headers 2. <code>flake8</code> - Python style checker 3. <code>mypy</code> - Static type checker</p> <p>All linting must pass before submitting a pull request.</p>"},{"location":"development/#building","title":"Building","text":"<pre><code># Build Cython extension\nmake build\n\n# Build distribution packages\nmake dist\n</code></pre> <p>The build process compiles <code>apywire/wiring.py</code> to C using Cython for performance.</p>"},{"location":"development/#complete-check","title":"Complete Check","text":"<p>Run all checks before committing:</p> <pre><code>make all\n</code></pre> <p>This runs: <code>format</code> \u2192 <code>lint</code> \u2192 <code>coverage</code> \u2192 <code>build</code></p>"},{"location":"development/#project-structure","title":"Project Structure","text":"<pre><code>apywire/\n\u251c\u2500\u2500 apywire/              # Main package\n\u2502   \u251c\u2500\u2500 __init__.py       # Public API exports\n\u2502   \u251c\u2500\u2500 wiring.py         # Base wiring functionality\n\u2502   \u251c\u2500\u2500 runtime.py        # Runtime wiring implementation\n\u2502   \u251c\u2500\u2500 compiler.py       # Code generation\n\u2502   \u251c\u2500\u2500 threads.py        # Thread safety utilities\n\u2502   \u251c\u2500\u2500 exceptions.py     # Exception classes\n\u2502   \u251c\u2500\u2500 constants.py      # Constants and configuration\n\u2502   \u2514\u2500\u2500 py.typed          # PEP 561 marker file\n\u251c\u2500\u2500 tests/                # Test suite\n\u2502   \u251c\u2500\u2500 test_single.py    # Runtime tests\n\u2502   \u251c\u2500\u2500 test_compile_aio.py  # Async compilation tests\n\u2502   \u251c\u2500\u2500 test_threading.py    # Thread safety tests\n\u2502   \u251c\u2500\u2500 test_factory_methods.py  # Factory method tests\n\u2502   \u251c\u2500\u2500 test_edge_cases.py   # Edge case tests\n\u2502   \u251c\u2500\u2500 test_stdlib_compat.py  # Stdlib compatibility tests\n\u2502   \u2514\u2500\u2500 test_internals.py    # Internal implementation tests\n\u251c\u2500\u2500 docs/                 # MkDocs documentation\n\u251c\u2500\u2500 pyproject.toml        # Project configuration\n\u251c\u2500\u2500 setup.py              # Build configuration (Cython)\n\u251c\u2500\u2500 Makefile              # Development commands\n\u2514\u2500\u2500 README.md             # Project readme\n</code></pre>"},{"location":"development/#code-standards","title":"Code Standards","text":""},{"location":"development/#type-annotations","title":"Type Annotations","text":"<p>apywire uses strict mypy with very aggressive settings:</p> <pre><code>[tool.mypy]\nstrict = true\ndisallow_any_unimported = true\ndisallow_any_decorated = true\ndisallow_any_explicit = true\ndisallow_subclassing_any = true\ndisallow_any_expr = true\nwarn_return_any = true\n</code></pre> <p>Guidelines: - No <code>Any</code>: Use <code>object</code> instead - Full type annotations on all functions and methods - Type all variables where type can't be inferred - Use type aliases for complex types</p> <p>Example:</p> <pre><code>from typing import TypeAlias\n\n# Good\ndef process(data: dict[str, str]) -&gt; list[str]:\n    return list(data.values())\n\n# Bad - missing return type\ndef process(data: dict[str, str]):\n    return list(data.values())\n</code></pre>"},{"location":"development/#code-style","title":"Code Style","text":"<ul> <li>Line length: 79 characters (enforced by <code>black</code>)</li> <li>Imports: Sorted with <code>isort</code>, profile <code>black</code></li> <li>Docstrings: Google style</li> <li>Naming:</li> <li>Classes: <code>PascalCase</code></li> <li>Functions/methods: <code>snake_case</code></li> <li>Constants: <code>UPPER_CASE</code></li> <li>Private: <code>_leading_underscore</code></li> </ul>"},{"location":"development/#spdx-licensing","title":"SPDX Licensing","text":"<p>All source files must have SPDX headers:</p> <pre><code># SPDX-FileCopyrightText: 2025 Alexandre Gomes Gaigalas &lt;alganet@gmail.com&gt;\n#\n# SPDX-License-Identifier: ISC\n</code></pre> <p>Run <code>make format</code> to automatically add headers to new files.</p>"},{"location":"development/#architecture","title":"Architecture","text":""},{"location":"development/#core-concepts","title":"Core Concepts","text":""},{"location":"development/#lazy-loading","title":"Lazy Loading","text":"<p>Objects are instantiated via <code>__getattr__</code> only when accessed:</p> <pre><code>def __getattr__(self, name: str):\n    if name in self._values:\n        return Accessor(lambda: self._values[name])\n    # Instantiate and cache...\n</code></pre>"},{"location":"development/#placeholder-resolution","title":"Placeholder Resolution","text":"<p>Strings like <code>{name}</code> are converted to <code>_WiredRef</code> markers during parsing:</p> <pre><code>class _WiredRef:\n    __slots__ = (\"name\",)\n\ndef _resolve(self, obj):\n    if isinstance(obj, str) and self._is_placeholder(obj):\n        return _WiredRef(ref_name)\n    return obj\n</code></pre> <p>At instantiation time, <code>_WiredRef</code> markers are resolved to actual objects.</p>"},{"location":"development/#thread-safety","title":"Thread Safety","text":"<p>Thread-safe mode uses: 1. Per-attribute locks: <code>dict[str, threading.Lock]</code> 2. Global fallback lock: Single <code>threading.Lock</code> 3. Thread-local state: For circular dependency detection</p> <p>See <code>apywire/threads.py</code> for details.</p>"},{"location":"development/#compilation","title":"Compilation","text":"<p>The compiler generates Python code that: 1. Imports all required modules 2. Creates a <code>Compiled</code> class 3. Generates accessor methods for each wired object 4. Optionally includes async accessors and thread safety</p> <p>See <code>apywire/compiler.py</code> for the implementation.</p>"},{"location":"development/#module-responsibilities","title":"Module Responsibilities","text":"<ul> <li><code>wiring.py</code>: Base class, type system, placeholder parsing</li> <li><code>runtime.py</code>: Runtime <code>Wiring</code> implementation, <code>Accessor</code>/<code>AioAccessor</code></li> <li><code>compiler.py</code>: Code generation via <code>WiringCompiler</code></li> <li><code>threads.py</code>: Thread safety mixins and utilities</li> <li><code>exceptions.py</code>: Custom exception classes</li> <li><code>constants.py</code>: Shared constants (delimiter, placeholder markers)</li> </ul>"},{"location":"development/#testing","title":"Testing","text":""},{"location":"development/#test-organization","title":"Test Organization","text":"<ul> <li><code>test_single.py</code>: Runtime wiring tests (non-thread-safe)</li> <li><code>test_threading.py</code>: Thread-safe wiring tests</li> <li><code>test_compile_aio.py</code>: Async compilation tests</li> <li><code>test_factory_methods.py</code>: Factory method tests</li> <li><code>test_edge_cases.py</code>: Edge cases and error handling</li> <li><code>test_stdlib_compat.py</code>: Standard library integration</li> <li><code>test_internals.py</code>: Internal implementation details</li> </ul>"},{"location":"development/#writing-tests","title":"Writing Tests","text":"<p>Test naming convention:</p> <pre><code>def test_&lt;feature&gt;_&lt;scenario&gt;_&lt;expected_behavior&gt;():\n    \"\"\"Brief description of what is being tested.\"\"\"\n    # Arrange\n    spec = {...}\n\n    # Act\n    wired = Wiring(spec)\n    result = wired.something()\n\n    # Assert\n    assert result == expected\n</code></pre> <p>Always test: 1. Runtime behavior 2. Compiled behavior (when applicable) 3. Async variants (when applicable) 4. Thread-safe variants (when applicable) 5. Error cases</p>"},{"location":"development/#coverage","title":"Coverage","text":"<p>Target: 95% branch coverage or higher</p> <p>Check coverage:</p> <pre><code>make coverage\n</code></pre> <p>View HTML coverage report:</p> <pre><code>open htmlcov/index.html\n</code></pre>"},{"location":"development/#documentation","title":"Documentation","text":""},{"location":"development/#building-docs","title":"Building Docs","text":"<pre><code># Serve docs locally\nmake docs-serve\n\n# Build static site\nmake docs-build\n</code></pre>"},{"location":"development/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use GitHub Flavored Markdown</li> <li>Include code examples that actually work</li> <li>Add SPDX headers to all <code>.md</code> files</li> <li>Use admonitions for important notes:</li> </ul> <pre><code>!!! note\n    This is a note\n\n!!! warning\n    This is a warning\n</code></pre>"},{"location":"development/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Create a branch from <code>main</code>:    <pre><code>git checkout -b feature/my-feature\n</code></pre></p> </li> <li> <p>Make changes and ensure tests pass:    <pre><code>make all\n</code></pre></p> </li> <li> <p>Commit changes with descriptive messages:    <pre><code>git commit -m \"Add feature X to handle Y\"\n</code></pre></p> </li> <li> <p>Push to GitHub:    <pre><code>git push origin feature/my-feature\n</code></pre></p> </li> <li> <p>Create pull request on GitHub</p> </li> <li> <p>Address review feedback if any</p> </li> </ol>"},{"location":"development/#release-process","title":"Release Process","text":"<p>(For maintainers)</p> <ol> <li>Update version in <code>pyproject.toml</code></li> <li>Update CHANGELOG (if present)</li> <li>Run full test suite: <code>make all</code></li> <li>Build distribution: <code>make dist</code></li> <li>Tag release: <code>git tag v0.x.x</code></li> <li>Push tag: <code>git push origin v0.x.x</code></li> <li>Publish to PyPI: <code>make publish</code></li> </ol>"},{"location":"development/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Documentation: Full Documentation</li> </ul>"},{"location":"development/#license","title":"License","text":"<p>apywire is licensed under the ISC License. See LICENSE for details.</p>"},{"location":"development/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Detailed API documentation</li> <li>User Guide - Learn how to use apywire</li> <li>Examples - Practical examples</li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#examples","title":"Examples","text":"<p>Illustrative examples showing how apywire can be used to wire objects in Python applications.</p>"},{"location":"examples/#configuration-management","title":"Configuration Management","text":"<p>Centralize configuration and inject it into services:</p> <pre><code>from apywire import Wiring\nimport os\n\nspec = {\n    # Configuration constants\n    \"db_host\": os.getenv(\"DB_HOST\", \"localhost\"),\n    \"db_port\": int(os.getenv(\"DB_PORT\", \"5432\")),\n    \"db_name\": os.getenv(\"DB_NAME\", \"myapp\"),\n    \"redis_url\": os.getenv(\"REDIS_URL\", \"redis://localhost\"),\n    \"debug\": os.getenv(\"DEBUG\", \"false\") == \"true\",\n\n    # Build database URL from config\n    \"MyApp app\": {\n        \"db_host\": \"{db_host}\",\n        \"db_port\": \"{db_port}\",\n        \"db_name\": \"{db_name}\",\n        \"redis_url\": \"{redis_url}\",\n        \"debug\": \"{debug}\",\n    },\n}\n\nwired = Wiring(spec)\napp = wired.app()\n</code></pre>"},{"location":"examples/#database-connection-pool","title":"Database Connection Pool","text":"<p>Set up a connection pool with dependency injection:</p> <pre><code>from apywire import Wiring\n\nspec = {\n    # Configuration\n    \"database_url\": \"postgresql://localhost/mydb\",\n    \"pool_min\": 1,\n    \"pool_max\": 20,\n\n    # Connection pool\n    \"psycopg2.pool.ThreadedConnectionPool pool\": {\n        \"minconn\": \"{pool_min}\",\n        \"maxconn\": \"{pool_max}\",\n        \"dsn\": \"{database_url}\",\n    },\n\n    # Repository using the pool\n    \"MyRepository users\": {\n        \"pool\": \"{pool}\",\n        \"table_name\": \"users\",\n    },\n}\n\nwired = Wiring(spec, thread_safe=True)\n\n# Access repository\nusers_repo = wired.users()\n</code></pre>"},{"location":"examples/#multi-layer-architecture","title":"Multi-Layer Architecture","text":"<p>Service layer with repositories and caching:</p> <pre><code>from apywire import Wiring\n\nspec = {\n    # Infrastructure layer\n    \"psycopg2.connect database\": {\n        \"dsn\": \"postgresql://localhost/mydb\",\n    },\n    \"redis.Redis cache\": {\n        \"host\": \"localhost\",\n        \"port\": 6379,\n    },\n\n    # Repository layer\n    \"UserRepository user_repo\": {\n        \"db\": \"{database}\",\n    },\n    \"ProductRepository product_repo\": {\n        \"db\": \"{database}\",\n    },\n\n    # Service layer\n    \"UserService user_service\": {\n        \"repo\": \"{user_repo}\",\n        \"cache\": \"{cache}\",\n    },\n    \"ProductService product_service\": {\n        \"repo\": \"{product_repo}\",\n        \"cache\": \"{cache}\",\n    },\n\n    # Application layer\n    \"Application app\": {\n        \"user_service\": \"{user_service}\",\n        \"product_service\": \"{product_service}\",\n    },\n}\n\nwired = Wiring(spec, thread_safe=True)\napp = wired.app()\n</code></pre>"},{"location":"examples/#fastapi-integration","title":"FastAPI Integration","text":"<p>Use apywire with FastAPI for dependency injection:</p> <pre><code>from fastapi import FastAPI, Depends\nfrom apywire import Wiring\n\n# Define your wiring spec\nspec = {\n    \"database_url\": \"postgresql://localhost/mydb\",\n    \"psycopg2.connect db\": {\"dsn\": \"{database_url}\"},\n    \"UserRepository user_repo\": {\"db\": \"{db}\"},\n    \"UserService user_service\": {\"repo\": \"{user_repo}\"},\n}\n\n# Create wiring container\nwired = Wiring(spec, thread_safe=True)\n\n# Create FastAPI app\napp = FastAPI()\n\n# Dependency providers\nasync def get_user_service():\n    \"\"\"Provide UserService via dependency injection.\"\"\"\n    return await wired.aio.user_service()\n\n# Route using dependency\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, service = Depends(get_user_service)):\n    \"\"\"Get user by ID.\"\"\"\n    user = await service.get_user(user_id)\n    return user\n</code></pre>"},{"location":"examples/#testing-with-mocks","title":"Testing with Mocks","text":"<p>Replace real dependencies with mocks for testing:</p> <pre><code>from apywire import Wiring\nfrom unittest.mock import Mock, MagicMock\nimport pytest\n\n# Production spec\nproduction_spec = {\n    \"psycopg2.connect db\": {\"dsn\": \"postgresql://prod/db\"},\n    \"redis.Redis cache\": {\"url\": \"redis://prod\"},\n    \"EmailService email\": {\"api_key\": \"real-api-key\"},\n    \"UserService user_service\": {\n        \"db\": \"{db}\",\n        \"cache\": \"{cache}\",\n        \"email\": \"{email}\",\n    },\n}\n\n# Test spec with mocks\ntest_spec = {\n    \"unittest.mock.Mock db\": {},\n    \"unittest.mock.Mock cache\": {},\n    \"unittest.mock.Mock email\": {},\n    \"UserService user_service\": {\n        \"db\": \"{db}\",\n        \"cache\": \"{cache}\",\n        \"email\": \"{email}\",\n    },\n}\n\n# Pytest fixture\n@pytest.fixture\ndef wired():\n    return Wiring(test_spec)\n\n# Test\ndef test_user_service(wired):\n    service = wired.user_service()\n\n    # Configure mocks\n    wired.db().execute = MagicMock(return_value=[{\"id\": 1, \"name\": \"Alice\"}])\n\n    # Test your service\n    users = service.get_users()\n    assert len(users) &gt; 0\n</code></pre>"},{"location":"examples/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>Different specs for different environments:</p> <pre><code>from apywire import Wiring\nimport os\n\ndef get_spec(env: str):\n    \"\"\"Get spec based on environment.\"\"\"\n    base_spec = {\n        \"log_level\": \"DEBUG\" if env == \"dev\" else \"INFO\",\n    }\n\n    if env == \"production\":\n        base_spec.update({\n            \"database_url\": \"postgresql://prod-server/db\",\n            \"redis_url\": \"redis://prod-server\",\n            \"cache_ttl\": 3600,\n        })\n    elif env == \"staging\":\n        base_spec.update({\n            \"database_url\": \"postgresql://staging-server/db\",\n            \"redis_url\": \"redis://staging-server\",\n            \"cache_ttl\": 600,\n        })\n    else:  # dev\n        base_spec.update({\n            \"database_url\": \"postgresql://localhost/dev_db\",\n            \"redis_url\": \"redis://localhost\",\n            \"cache_ttl\": 60,\n        })\n\n    # Add wired services\n    base_spec.update({\n        \"psycopg2.connect db\": {\"dsn\": \"{database_url}\"},\n        \"redis.Redis cache\": {\n            \"url\": \"{redis_url}\",\n            \"ttl\": \"{cache_ttl}\",\n        },\n    })\n\n    return base_spec\n\n# Usage\nenv = os.getenv(\"APP_ENV\", \"dev\")\nwired = Wiring(get_spec(env), thread_safe=env == \"production\")\n</code></pre>"},{"location":"examples/#factory-pattern","title":"Factory Pattern","text":"<p>Use factory methods for complex object creation:</p> <pre><code>from apywire import Wiring\nfrom datetime import datetime\n\nspec = {\n    # Use factory method to create from timestamp\n    \"datetime.datetime app_start.fromtimestamp\": {\n        0: 1704067200,  # Jan 1, 2024\n    },\n\n    # Use factory method with ISO format\n    \"datetime.datetime launch_date.fromisoformat\": {\n        \"date_string\": \"2024-06-15T12:00:00\",\n    },\n\n    # Custom factory method\n    \"myapp.Config config.from_env\": {},  # Loads from environment\n\n    # Service using factory-created objects\n    \"myapp.Scheduler scheduler\": {\n        \"start_time\": \"{app_start}\",\n        \"config\": \"{config}\",\n    },\n}\n\nwired = Wiring(spec)\nscheduler = wired.scheduler()\n</code></pre>"},{"location":"examples/#logging-setup","title":"Logging Setup","text":"<p>Configure logging infrastructure:</p> <pre><code>from apywire import Wiring\nimport logging\n\nspec = {\n    # Log level configuration\n    \"log_level\": \"INFO\",\n    \"log_format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n\n    # Logger instances\n    \"logging.Logger app_logger\": {\n        \"name\": \"myapp\",\n    },\n    \"logging.Logger db_logger\": {\n        \"name\": \"myapp.database\",\n    },\n    \"logging.Logger api_logger\": {\n        \"name\": \"myapp.api\",\n    },\n\n    # Services using loggers\n    \"DatabaseService db_service\": {\n        \"logger\": \"{db_logger}\",\n    },\n    \"APIService api_service\": {\n        \"logger\": \"{api_logger}\",\n    },\n}\n\nwired = Wiring(spec)\n\n# Configure log levels\napp_logger = wired.app_logger()\napp_logger.setLevel(logging.INFO)\n\n# Use services with logging\ndb_service = wired.db_service()\n</code></pre>"},{"location":"examples/#microservices-communication","title":"Microservices Communication","text":"<p>Set up clients for microservices:</p> <pre><code>from apywire import Wiring\n\nspec = {\n    # Service endpoints\n    \"auth_service_url\": \"https://auth.example.com\",\n    \"user_service_url\": \"https://users.example.com\",\n    \"payment_service_url\": \"https://payments.example.com\",\n\n    # HTTP clients for each service\n    \"requests.Session auth_client\": {},\n    \"requests.Session user_client\": {},\n    \"requests.Session payment_client\": {},\n\n    # Service wrappers\n    \"AuthService auth\": {\n        \"base_url\": \"{auth_service_url}\",\n        \"client\": \"{auth_client}\",\n    },\n    \"UserService users\": {\n        \"base_url\": \"{user_service_url}\",\n        \"client\": \"{user_client}\",\n    },\n    \"PaymentService payments\": {\n        \"base_url\": \"{payment_service_url}\",\n        \"client\": \"{payment_client}\",\n    },\n\n    # Orchestrator\n    \"OrderOrchestrator orchestrator\": {\n        \"auth\": \"{auth}\",\n        \"users\": \"{users}\",\n        \"payments\": \"{payments}\",\n    },\n}\n\nwired = Wiring(spec, thread_safe=True)\norchestrator = wired.orchestrator()\n</code></pre>"},{"location":"examples/#file-processing-pipeline","title":"File Processing Pipeline","text":"<p>Build a data processing pipeline:</p> <pre><code>from apywire import Wiring\n\nspec = {\n    # Input/output paths\n    \"input_path\": \"/data/input\",\n    \"output_path\": \"/data/output\",\n    \"temp_path\": \"/data/temp\",\n\n    # Path objects\n    \"pathlib.Path input_dir\": [\"{input_path}\"],\n    \"pathlib.Path output_dir\": [\"{output_path}\"],\n    \"pathlib.Path temp_dir\": [\"{temp_path}\"],\n\n    # Pipeline stages\n    \"FileReader reader\": {\n        \"input_dir\": \"{input_dir}\",\n    },\n    \"DataValidator validator\": {},\n    \"DataTransformer transformer\": {\n        \"temp_dir\": \"{temp_dir}\",\n    },\n    \"DataWriter writer\": {\n        \"output_dir\": \"{output_dir}\",\n    },\n\n    # Pipeline\n    \"ProcessingPipeline pipeline\": {\n        \"reader\": \"{reader}\",\n        \"validator\": \"{validator}\",\n        \"transformer\": \"{transformer}\",\n        \"writer\": \"{writer}\",\n    },\n}\n\nwired = Wiring(spec)\npipeline = wired.pipeline()\npipeline.run()\n</code></pre>"},{"location":"examples/#scheduled-tasks","title":"Scheduled Tasks","text":"<p>Set up scheduled tasks with dependencies:</p> <pre><code>from apywire import Wiring\nimport schedule\n\nspec = {\n    # Database connection\n    \"psycopg2.connect db\": {\"dsn\": \"postgresql://localhost/mydb\"},\n\n    # Email service\n    \"EmailService email\": {\"api_key\": \"secret\"},\n\n    # Task definitions\n    \"DailyReportTask daily_report\": {\n        \"db\": \"{db}\",\n        \"email\": \"{email}\",\n        \"schedule\": \"00:00\",  # Midnight\n    },\n    \"HourlyCleanupTask cleanup\": {\n        \"db\": \"{db}\",\n        \"schedule\": \":00\",  # Every hour\n    },\n\n    # Scheduler\n    \"TaskScheduler scheduler\": {\n        \"tasks\": [\"{daily_report}\", \"{cleanup}\"],\n    },\n}\n\nwired = Wiring(spec, thread_safe=True)\nscheduler = wired.scheduler()\n\n# Schedule tasks\nfor task in [wired.daily_report(), wired.cleanup()]:\n    schedule.every().day.at(task.schedule).do(task.run)\n\n# Run scheduler\nwhile True:\n    schedule.run_pending()\n    time.sleep(60)\n</code></pre>"},{"location":"examples/#cli-application","title":"CLI Application","text":"<p>Build a command-line application:</p> <pre><code>from apywire import Wiring\nimport argparse\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--env\", default=\"dev\")\n    parser.add_argument(\"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n\n    spec = {\n        \"env\": args.env,\n        \"verbose\": args.verbose,\n\n        # Configuration\n        \"Config config\": {\n            \"env\": \"{env}\",\n            \"verbose\": \"{verbose}\",\n        },\n\n        # Services\n        \"Database db\": {\"config\": \"{config}\"},\n        \"Logger logger\": {\"verbose\": \"{verbose}\"},\n\n        # CLI\n        \"CLI cli\": {\n            \"db\": \"{db}\",\n            \"logger\": \"{logger}\",\n        },\n    }\n\n    wired = Wiring(spec)\n    cli = wired.cli()\n    cli.run()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>User Guide - Detailed documentation</li> <li>API Reference - Complete API documentation</li> <li>Development - Contributing guide</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting Started","text":"<p>This guide will help you get up and running with apywire quickly.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install apywire using pip:</p> <pre><code>pip install apywire\n</code></pre> <p>apywire requires Python 3.12 or later and has no external runtime dependencies.</p>"},{"location":"getting-started/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to apywire or run the tests:</p> <pre><code>git clone https://github.com/alganet/apywire.git\ncd apywire\nmake .venv\nsource .venv/bin/activate\nmake pip\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#basic-wiring","title":"Basic Wiring","text":"<p>Create a simple wiring configuration to manage object instantiation:</p> <pre><code>from apywire import Wiring\n\n# Define your wiring spec\nspec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\n# Create the wiring container\nwired = Wiring(spec)\n\n# Access the object (instantiated lazily on first call)\ndt = wired.now()\nprint(dt)  # 2025-01-01 00:00:00\n</code></pre>"},{"location":"getting-started/#understanding-the-spec-format","title":"Understanding the Spec Format","text":"<p>The wiring spec uses the format: <code>\"module.Class name\": {parameters}</code></p> <ul> <li><code>module.Class</code>: Full module path and class name</li> <li><code>name</code>: Attribute name to access the wired object</li> <li><code>{parameters}</code>: Dictionary or list of constructor parameters</li> </ul> <p>Examples:</p> <pre><code>spec = {\n    # Basic class with keyword arguments\n    \"datetime.datetime dt\": {\"year\": 2025, \"month\": 6, \"day\": 15},\n\n    # Class with positional arguments (using list)\n    \"pathlib.Path root\": [\"/home/user\"],\n\n    # Class with positional arguments (using numeric dict keys)\n    \"pathlib.Path project\": {0: \"/home/user/project\"},\n\n    # Constant values (no module.Class prefix)\n    \"port\": 8080,\n    \"host\": \"localhost\",\n}\n</code></pre>"},{"location":"getting-started/#using-placeholders","title":"Using Placeholders","text":"<p>Reference other wired objects using the <code>{name}</code> syntax:</p> <pre><code>from apywire import Wiring\n\nspec = {\n    \"datetime.datetime start\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n    \"datetime.timedelta delta\": {\"days\": 7},\n    \"MyScheduler scheduler\": {\n        \"start_time\": \"{start}\",  # References the 'start' object\n        \"duration\": \"{delta}\",     # References the 'delta' object\n    },\n}\n\nwired = Wiring(spec)\nscheduler = wired.scheduler()  # MyScheduler with injected dependencies\n</code></pre>"},{"location":"getting-started/#lazy-loading","title":"Lazy Loading","text":"<p>Objects are only instantiated when you call the accessor:</p> <pre><code>wired = Wiring(spec)\n# Nothing has been instantiated yet!\n\nobj1 = wired.my_object()  # Now it's created\nobj2 = wired.my_object()  # Returns the same cached instance\nassert obj1 is obj2  # True - same object!\n</code></pre>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/#1-wiring-container","title":"1. Wiring Container","text":"<p>The <code>Wiring</code> class is your main container that holds the spec and manages object instantiation:</p> <pre><code>from apywire import Wiring\n\nwired = Wiring(spec)\n</code></pre>"},{"location":"getting-started/#2-accessors","title":"2. Accessors","text":"<p>When you access an attribute on the <code>Wiring</code> container, you get an <code>Accessor</code> - a callable that instantiates the object:</p> <pre><code>accessor = wired.my_object  # Returns an Accessor\nobj = accessor()              # Calls the accessor to get the object\n# Or in one step:\nobj = wired.my_object()\n</code></pre>"},{"location":"getting-started/#3-spec-dictionary","title":"3. Spec Dictionary","text":"<p>The spec is a dictionary that maps wiring keys to configuration:</p> <ul> <li>Wiring keys with <code>module.Class name</code> format create wired objects</li> <li>Simple keys without a dot+class create constant values</li> </ul>"},{"location":"getting-started/#4-dependency-resolution","title":"4. Dependency Resolution","text":"<p>When you access a wired object:</p> <ol> <li>apywire checks if it's already cached</li> <li>If not, it resolves all placeholder references (<code>{name}</code>)</li> <li>Imports the module and class</li> <li>Instantiates the object with the resolved parameters</li> <li>Caches it for future access</li> </ol>"},{"location":"getting-started/#5-circular-dependency-detection","title":"5. Circular Dependency Detection","text":"<p>apywire automatically detects circular dependencies:</p> <pre><code>spec = {\n    \"MyClass a\": {\"dependency\": \"{b}\"},\n    \"MyClass b\": {\"dependency\": \"{a}\"},  # Circular!\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.a()\nexcept CircularWiringError as e:\n    print(f\"Circular dependency detected: {e}\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore more advanced features:</p> <ul> <li>Basic Usage - Detailed usage patterns and examples</li> <li>Async Support - Using <code>await wired.aio.name()</code> for async access</li> <li>Thread Safety - Thread-safe instantiation for multi-threaded apps</li> <li>Compilation - Generate standalone Python code from your spec</li> <li>Advanced Features - Factory methods, positional args, and more</li> <li>Examples - Practical use cases and patterns</li> </ul>"},{"location":"getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/#configuration-management","title":"Configuration Management","text":"<pre><code>spec = {\n    \"host\": \"localhost\",\n    \"port\": 8080,\n    \"MyApp app\": {\n        \"host\": \"{host}\",\n        \"port\": \"{port}\",\n    },\n}\n</code></pre>"},{"location":"getting-started/#database-connection","title":"Database Connection","text":"<pre><code>spec = {\n    \"db_url\": \"postgresql://localhost/mydb\",\n    \"psycopg2.connect connection\": {\"dsn\": \"{db_url}\"},\n    \"MyRepository repo\": {\"db\": \"{connection}\"},\n}\n</code></pre>"},{"location":"getting-started/#service-layer","title":"Service Layer","text":"<pre><code>spec = {\n    \"MyDatabase db\": {},\n    \"MyCache cache\": {},\n    \"MyService service\": {\n        \"database\": \"{db}\",\n        \"cache\": \"{cache}\",\n    },\n}\n</code></pre>"},{"location":"user-guide/","title":"Index","text":""},{"location":"user-guide/#user-guide","title":"User Guide","text":"<p>Welcome to the apywire user guide! This section provides comprehensive documentation on all features and capabilities of apywire.</p>"},{"location":"user-guide/#contents","title":"Contents","text":""},{"location":"user-guide/#basic-usage","title":"Basic Usage","text":"<p>Learn the fundamentals of using apywire, including creating wiring containers, defining specs, using the Accessor pattern, and understanding caching behavior.</p>"},{"location":"user-guide/#configuration-files","title":"Configuration Files","text":"<p>Load specs from YAML, TOML, JSON, or INI files. Mix configuration files with environment variables and implement environment-based configs.</p>"},{"location":"user-guide/#async-support","title":"Async Support","text":"<p>Discover how to use apywire in asynchronous contexts with <code>await wired.aio.name()</code> for async object access.</p>"},{"location":"user-guide/#thread-safety","title":"Thread Safety","text":"<p>Understand thread-safe instantiation, optimistic locking mechanisms, and configuration options for multi-threaded applications.</p>"},{"location":"user-guide/#compilation","title":"Compilation","text":"<p>Learn how to generate standalone Python code from your wiring specs using <code>WiringCompiler</code> for production deployment and performance optimization.</p>"},{"location":"user-guide/#spec-generation","title":"Spec Generation","text":"<p>Quickly scaffold wiring specs from class constructor signatures using <code>Generator</code>.</p>"},{"location":"user-guide/#advanced-features","title":"Advanced Features","text":"<p>Explore advanced capabilities including factory methods, positional arguments, complex nested dependencies, error handling, and best practices.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>apywire is designed around a few core principles:</p> <ol> <li>Lazy Loading: Objects are instantiated only when accessed, improving startup performance</li> <li>Dependency Injection: Use placeholder syntax to express dependencies between objects</li> <li>Flexibility: Support for keyword arguments, positional arguments, factory methods, and constants</li> <li>Type Safety: Strict mypy typing throughout the library</li> <li>Performance: Optional code generation via Cython for production deployments</li> </ol>"},{"location":"user-guide/#quick-navigation","title":"Quick Navigation","text":"<p>Looking for something specific?</p> <ul> <li>Getting started? \u2192 Basic Usage</li> <li>Need async? \u2192 Async Support</li> <li>Multi-threaded app? \u2192 Thread Safety</li> <li>Production deployment? \u2192 Compilation</li> <li>Complex use cases? \u2192 Advanced Features</li> <li>Scaffold specs quickly? \u2192 Spec Generation</li> </ul>"},{"location":"user-guide/#common-workflows","title":"Common Workflows","text":""},{"location":"user-guide/#development","title":"Development","text":"<ol> <li>Define your wiring spec with dependencies</li> <li>Create a <code>Wiring</code> container</li> <li>Access objects via the Accessor pattern</li> <li>Use <code>thread_safe=False</code> for single-threaded development</li> </ol>"},{"location":"user-guide/#production","title":"Production","text":"<ol> <li>Test your wiring configuration thoroughly</li> <li>Use <code>WiringCompiler</code> to generate standalone code</li> <li>Enable <code>thread_safe=True</code> if deploying multi-threaded</li> <li>Optionally compile with Cython for maximum performance</li> </ol>"},{"location":"user-guide/#testing","title":"Testing","text":"<ol> <li>Define test-specific specs with mock objects</li> <li>Use placeholder references to inject test doubles</li> <li>Leverage lazy loading to avoid unnecessary instantiation</li> <li>Test circular dependency error handling</li> </ol>"},{"location":"user-guide/#best-practices","title":"Best Practices","text":"<ul> <li>Keep specs simple: Break complex wiring into smaller, focused specs</li> <li>Use placeholders: Express dependencies explicitly with <code>{name}</code> syntax</li> <li>Validate early: Access all wired objects in tests to catch configuration errors</li> <li>Document dependencies: Comment complex dependency chains in your specs</li> <li>Consider thread safety: Enable <code>thread_safe=True</code> only when needed (has overhead)</li> <li>Compile for production: Use <code>WiringCompiler</code> to generate optimized code</li> </ul>"},{"location":"user-guide/#next-steps","title":"Next Steps","text":"<p>Start with Basic Usage to learn the fundamentals, then explore the other guides based on your specific needs.</p>"},{"location":"user-guide/advanced/","title":"Advanced Features","text":""},{"location":"user-guide/advanced/#advanced-features","title":"Advanced Features","text":"<p>This guide covers advanced apywire features and patterns for complex use cases.</p>"},{"location":"user-guide/advanced/#factory-methods","title":"Factory Methods","text":"<p>apywire supports class factory methods (classmethods and staticmethods) using the syntax <code>module.Class name.factory_method</code>.</p>"},{"location":"user-guide/advanced/#basic-factory-method","title":"Basic Factory Method","text":"<pre><code>import datetime\nfrom apywire import Wiring\n\nspec = {\n    \"datetime.datetime dt.fromtimestamp\": {\n        0: 1234567890,  # Unix timestamp\n    },\n}\n\nwired = Wiring(spec)\ndt = wired.dt()  # datetime.datetime.fromtimestamp(1234567890)\n</code></pre>"},{"location":"user-guide/advanced/#with-keyword-arguments","title":"With Keyword Arguments","text":"<pre><code>spec = {\n    \"datetime.datetime dt.fromisoformat\": {\n        \"date_string\": \"2025-01-01T12:00:00\",\n    },\n}\n\nwired = Wiring(spec)\ndt = wired.dt()  # datetime.datetime.fromisoformat(\"2025-01-01T12:00:00\")\n</code></pre>"},{"location":"user-guide/advanced/#custom-factory-methods","title":"Custom Factory Methods","text":"<pre><code>class Product:\n    def __init__(self, name: str, price: float):\n        self.name = name\n        self.price = price\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        return cls(name=data[\"name\"], price=data[\"price\"])\n\nspec = {\n    \"mymodule.Product product.from_dict\": {\n        \"data\": {\"name\": \"Widget\", \"price\": 19.99},\n    },\n}\n</code></pre>"},{"location":"user-guide/advanced/#with-placeholders","title":"With Placeholders","text":"<pre><code>spec = {\n    \"mymodule.Config config\": {\"value\": \"production\"},\n    \"mymodule.Service service.from_config\": {\n        \"cfg\": \"{config}\",  # Reference to config object\n    },\n}\n</code></pre>"},{"location":"user-guide/advanced/#static-methods","title":"Static Methods","text":"<p>Factory methods can be staticmethods too:</p> <pre><code>class Calculator:\n    def __init__(self, result: int):\n        self.result = result\n\n    @staticmethod\n    def create_with_sum(a: int, b: int):\n        return Calculator(result=a + b)\n\nspec = {\n    \"mymodule.Calculator calc.create_with_sum\": {\n        \"a\": 10,\n        \"b\": 20,\n    },\n}\n\nwired = Wiring(spec)\ncalc = wired.calc()\nassert calc.result == 30\n</code></pre> <p>Nested Factory Methods Not Supported</p> <pre><code># \u274c This will raise ValueError\nspec = {\n    \"datetime.datetime dt.method1.method2\": {},\n}\n</code></pre> <p>Nested factory methods are not supported. Only one level is allowed: <code>name.factory_method</code>.</p>"},{"location":"user-guide/advanced/#positional-arguments","title":"Positional Arguments","text":"<p>apywire supports positional arguments in three ways:</p>"},{"location":"user-guide/advanced/#using-lists","title":"Using Lists","text":"<pre><code>spec = {\n    \"pathlib.Path path\": [\"/home\", \"user\", \"project\"],\n}\n\nwired = Wiring(spec)\npath = wired.path()  # pathlib.Path(\"/home\", \"user\", \"project\")\n</code></pre>"},{"location":"user-guide/advanced/#using-numeric-dict-keys","title":"Using Numeric Dict Keys","text":"<pre><code>spec = {\n    \"pathlib.Path path\": {\n        0: \"/home\",\n        1: \"user\",\n        2: \"project\",\n    },\n}\n</code></pre> <p>Keys are sorted numerically and passed as positional arguments.</p>"},{"location":"user-guide/advanced/#mixed-positional-and-keyword-args","title":"Mixed Positional and Keyword Args","text":"<pre><code>spec = {\n    \"datetime.datetime dt\": {\n        0: 2025,  # year (positional)\n        1: 1,     # month (positional)\n        2: 1,     # day (positional)\n        \"hour\": 12,     # keyword argument\n        \"minute\": 30,   # keyword argument\n    },\n}\n\nwired = Wiring(spec)\ndt = wired.dt()  # datetime.datetime(2025, 1, 1, hour=12, minute=30)\n</code></pre>"},{"location":"user-guide/advanced/#complex-nested-dependencies","title":"Complex Nested Dependencies","text":""},{"location":"user-guide/advanced/#deep-dependency-chains","title":"Deep Dependency Chains","text":"<pre><code>spec = {\n    \"DatabaseConfig db_config\": {},\n    \"Database db\": {\"config\": \"{db_config}\"},\n    \"CacheLayer cache\": {\"db\": \"{db}\"},\n    \"RepositoryLayer repo\": {\n        \"db\": \"{db}\",\n        \"cache\": \"{cache}\",\n    },\n    \"ServiceLayer service\": {\n        \"repo\": \"{repo}\",\n        \"cache\": \"{cache}\",\n    },\n}\n\nwired = Wiring(spec)\nservice = wired.service()\n# Resolves: db_config \u2192 db \u2192 cache \u2192 repo \u2192 service\n</code></pre>"},{"location":"user-guide/advanced/#nested-data-structures","title":"Nested Data Structures","text":"<p>Placeholders work in nested dicts, lists, and tuples:</p> <pre><code>spec = {\n    \"api_key\": \"secret-key-123\",\n    \"timeout\": 30,\n\n    \"MyClient client\": {\n        \"config\": {\n            \"auth\": {\n                \"type\": \"bearer\",\n                \"token\": \"{api_key}\",  # Nested in dict\n            },\n            \"options\": {\n                \"timeout\": \"{timeout}\",\n                \"retries\": 3,\n            },\n        },\n        \"endpoints\": [\n            \"https://api1.example.com\",\n            \"https://api2.example.com\",\n        ],\n    },\n}\n</code></pre>"},{"location":"user-guide/advanced/#multiple-references-to-same-object","title":"Multiple References to Same Object","text":"<pre><code>spec = {\n    \"Logger logger\": {},\n    \"ServiceA svc_a\": {\"logger\": \"{logger}\"},\n    \"ServiceB svc_b\": {\"logger\": \"{logger}\"},\n    \"Coordinator coord\": {\n        \"logger\": \"{logger}\",\n        \"services\": [\"{svc_a}\", \"{svc_b}\"],\n    },\n}\n\nwired = Wiring(spec)\ncoord = wired.coord()\n\n# All services share the same logger instance\nassert coord.logger is coord.services[0].logger\nassert coord.logger is coord.services[1].logger\n</code></pre>"},{"location":"user-guide/advanced/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/advanced/#circularwiringerror","title":"CircularWiringError","text":"<p>Raised when a circular dependency is detected:</p> <pre><code>from apywire import CircularWiringError\n\nspec = {\n    \"MyClass a\": {\"dependency\": \"{b}\"},\n    \"MyClass b\": {\"dependency\": \"{a}\"},  # Circular!\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.a()\nexcept CircularWiringError as e:\n    print(f\"Circular dependency: {e}\")\n    # Error message shows the dependency chain\n</code></pre> <p>The error message includes the full resolution chain:</p> <pre><code>Circular dependency detected while resolving 'a':\n  a -&gt; b -&gt; a\n</code></pre>"},{"location":"user-guide/advanced/#unknownplaceholdererror","title":"UnknownPlaceholderError","text":"<p>Raised when a placeholder references a non-existent object:</p> <pre><code>from apywire import UnknownPlaceholderError\n\nspec = {\n    \"MyClass obj\": {\"dependency\": \"{nonexistent}\"},\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.obj()\nexcept UnknownPlaceholderError as e:\n    print(f\"Unknown placeholder: {e}\")\n</code></pre>"},{"location":"user-guide/advanced/#lockunavailableerror","title":"LockUnavailableError","text":"<p>Raised in thread-safe mode when a lock cannot be acquired:</p> <pre><code>from apywire import LockUnavailableError\n\nwired = Wiring(spec, thread_safe=True, max_lock_attempts=1)\n\ntry:\n    obj = wired.my_object()\nexcept LockUnavailableError as e:\n    print(f\"Lock contention: {e}\")\n</code></pre> <p>This is rare and usually indicates extreme contention or a configuration issue.</p>"},{"location":"user-guide/advanced/#import-errors","title":"Import Errors","text":"<p>If a module or class can't be imported, a standard <code>ImportError</code> is raised:</p> <pre><code>spec = {\n    \"nonexistent.module.Class obj\": {},\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.obj()\nexcept ImportError as e:\n    print(f\"Cannot import: {e}\")\n</code></pre>"},{"location":"user-guide/advanced/#attribute-errors","title":"Attribute Errors","text":"<p>If a class doesn't have the specified factory method:</p> <pre><code>spec = {\n    \"datetime.datetime dt.nonexistent_method\": {},\n}\n\nwired = Wiring(spec)\ntry:\n    dt = wired.dt()\nexcept AttributeError as e:\n    print(f\"Method not found: {e}\")\n</code></pre>"},{"location":"user-guide/advanced/#standard-library-compatibility","title":"Standard Library Compatibility","text":"<p>apywire works with Python standard library classes:</p>"},{"location":"user-guide/advanced/#datetime","title":"datetime","text":"<pre><code>spec = {\n    \"datetime.datetime now.fromtimestamp\": {0: 1234567890},\n    \"datetime.timedelta duration\": {\"days\": 7, \"hours\": 12},\n    \"datetime.date today.fromisoformat\": {\"date_string\": \"2025-01-01\"},\n}\n</code></pre>"},{"location":"user-guide/advanced/#pathlib","title":"pathlib","text":"<pre><code>spec = {\n    \"pathlib.Path root\": [\"/home/user\"],\n    \"pathlib.Path project\": {0: \"/home/user/project\"},\n}\n</code></pre>"},{"location":"user-guide/advanced/#collections","title":"collections","text":"<pre><code>spec = {\n    \"collections.Counter counter\": [[\"a\", \"b\", \"a\", \"c\", \"b\", \"a\"]],\n    \"collections.defaultdict dd\": {\"default_factory\": list},\n}\n</code></pre>"},{"location":"user-guide/advanced/#threading","title":"threading","text":"<pre><code>spec = {\n    \"threading.Lock lock\": {},\n    \"threading.Event event\": {},\n    \"threading.Semaphore sem\": {0: 5},\n}\n</code></pre>"},{"location":"user-guide/advanced/#dynamic-spec-building","title":"Dynamic Spec Building","text":"<p>Build specs programmatically:</p> <pre><code>def build_spec(env: str) -&gt; dict:\n    \"\"\"Build spec based on environment.\"\"\"\n    spec = {\n        \"log_level\": \"DEBUG\" if env == \"dev\" else \"INFO\",\n    }\n\n    if env == \"production\":\n        spec[\"database_url\"] = \"postgresql://prod-server/db\"\n    else:\n        spec[\"database_url\"] = \"sqlite:///dev.db\"\n\n    spec[\"MyDatabase db\"] = {\"url\": \"{database_url}\"}\n\n    return spec\n\n# Usage\nimport os\nenv = os.getenv(\"APP_ENV\", \"dev\")\nwired = Wiring(build_spec(env))\n</code></pre>"},{"location":"user-guide/advanced/#testing-patterns","title":"Testing Patterns","text":""},{"location":"user-guide/advanced/#mock-dependencies","title":"Mock Dependencies","text":"<p>Replace real dependencies with mocks for testing:</p> <pre><code># production_spec.py\nproduction_spec = {\n    \"psycopg2.connect db\": {\"dsn\": \"postgresql://prod/db\"},\n    \"redis.Redis cache\": {\"url\": \"redis://prod\"},\n}\n\n# test_spec.py\nfrom unittest.mock import Mock\n\ntest_spec = {\n    \"unittest.mock.Mock db\": {},  # Mock database\n    \"unittest.mock.Mock cache\": {},  # Mock cache\n}\n\n# In tests\ndef test_my_app():\n    wired = Wiring(test_spec)\n    # All dependencies are mocks\n</code></pre>"},{"location":"user-guide/advanced/#spec-fixtures","title":"Spec Fixtures","text":"<p>Use pytest fixtures for common specs:</p> <pre><code>import pytest\nfrom apywire import Wiring\n\n@pytest.fixture\ndef wired():\n    spec = {\n        \"MyDatabase db\": {},\n        \"MyCache cache\": {},\n        \"MyService service\": {\n            \"db\": \"{db}\",\n            \"cache\": \"{cache}\",\n        },\n    }\n    return Wiring(spec)\n\ndef test_service(wired):\n    service = wired.service()\n    assert service is not None\n</code></pre>"},{"location":"user-guide/advanced/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/advanced/#1-use-type-aliases-for-complex-specs","title":"1. Use Type Aliases for Complex Specs","text":"<pre><code>from typing import TypeAlias\nfrom apywire import Spec\n\nDatabaseSpec: TypeAlias = Spec\n\ndef get_database_spec() -&gt; DatabaseSpec:\n    return {\n        \"database_url\": \"postgresql://localhost/db\",\n        \"psycopg2.connect connection\": {\"dsn\": \"{database_url}\"},\n    }\n</code></pre>"},{"location":"user-guide/advanced/#2-validate-specs-early","title":"2. Validate Specs Early","text":"<pre><code>def validate_spec(wired: Wiring) -&gt; None:\n    \"\"\"Validate all wired objects can be instantiated.\"\"\"\n    # Try to access all known objects\n    _ = wired.database()\n    _ = wired.cache()\n    _ = wired.service()\n\n# Fail fast at application startup\nwired = Wiring(spec)\nvalidate_spec(wired)\n</code></pre>"},{"location":"user-guide/advanced/#3-document-complex-dependencies","title":"3. Document Complex Dependencies","text":"<pre><code>spec = {\n    # Core infrastructure\n    \"database_url\": \"postgresql://localhost/db\",\n    \"psycopg2.connect db\": {\"dsn\": \"{database_url}\"},\n\n    # Caching layer (depends on db)\n    \"MyCache cache\": {\"db\": \"{db}\"},\n\n    # Business logic (depends on db and cache)\n    \"MyService service\": {\n        \"db\": \"{db}\",\n        \"cache\": \"{cache}\",\n    },\n}\n</code></pre>"},{"location":"user-guide/advanced/#4-separate-concerns","title":"4. Separate Concerns","text":"<pre><code># config.py - Configuration constants\nconfig_spec = {\n    \"host\": \"localhost\",\n    \"port\": 8080,\n    \"debug\": True,\n}\n\n# infrastructure.py - Infrastructure components\ninfra_spec = {\n    \"Database db\": {\"host\": \"{host}\", \"port\": \"{port}\"},\n    \"Cache cache\": {},\n}\n\n# services.py - Business logic\nservice_spec = {\n    \"MyService service\": {\"db\": \"{db}\", \"cache\": \"{cache}\"},\n}\n\n# Merge them\nfull_spec = {**config_spec, **infra_spec, **service_spec}\nwired = Wiring(full_spec)\n</code></pre>"},{"location":"user-guide/advanced/#5-use-constants-for-configuration","title":"5. Use Constants for Configuration","text":"<p>Constants now support placeholder expansion, making configuration more maintainable:</p> <pre><code>spec = {\n    # Configuration constants\n    \"db_host\": \"localhost\",\n    \"db_port\": 5432,\n    \"db_name\": \"myapp\",\n\n    # Build connection string from constants (immediate expansion)\n    \"db_url\": \"postgresql://{db_host}:{db_port}/{db_name}\",\n\n    # Use in wired object\n    \"psycopg2.connect db\": {\"dsn\": \"{db_url}\"},\n}\n</code></pre> <p>For environment-based configuration:</p> <pre><code>import os\n\nspec = {\n    \"db_host\": os.getenv(\"DB_HOST\", \"localhost\"),\n    \"db_port\": int(os.getenv(\"DB_PORT\", \"5432\")),\n    \"db_name\": os.getenv(\"DB_NAME\", \"myapp\"),\n\n    # Placeholder expansion keeps spec clean\n    \"db_url\": \"postgresql://{db_host}:{db_port}/{db_name}\",\n    \"psycopg2.connect db\": {\"dsn\": \"{db_url}\"},\n}\n</code></pre> <p>See Configuration Files for more details.</p>"},{"location":"user-guide/advanced/#performance-tips","title":"Performance Tips","text":""},{"location":"user-guide/advanced/#1-lazy-loading-is-your-friend","title":"1. Lazy Loading is Your Friend","text":"<p>Objects are only created when accessed, so define everything in your spec:</p> <pre><code>spec = {\n    \"ExpensiveResource resource1\": {},  # Won't be created unless accessed\n    \"ExpensiveResource resource2\": {},  # Same here\n    \"QuickResource quick\": {},\n}\n\nwired = Wiring(spec)\nquick = wired.quick()  # Only this is instantiated\n</code></pre>"},{"location":"user-guide/advanced/#2-cache-is-per-container","title":"2. Cache is Per-Container","text":"<p>Each <code>Wiring</code> instance has its own cache:</p> <pre><code># \u2705 Good: Single container, shared cache\nwired = Wiring(spec)\nobj1 = wired.resource()  # Created\nobj2 = wired.resource()  # Cached\n\n# \u274c Avoid: Multiple containers, no sharing\nwired1 = Wiring(spec)\nwired2 = Wiring(spec)\nobj1 = wired1.resource()  # Created\nobj2 = wired2.resource()  # Created again!\n</code></pre>"},{"location":"user-guide/advanced/#3-use-compilation-for-production","title":"3. Use Compilation for Production","text":"<p>Compiled code is slightly faster:</p> <pre><code># Development: runtime\nwired = Wiring(spec)\n\n# Production: compiled\ncompiler = WiringCompiler(spec)\ncode = compiler.compile()\n# Save to file, import in production\n</code></pre>"},{"location":"user-guide/advanced/#4-thread-safety-has-overhead","title":"4. Thread Safety Has Overhead","text":"<p>Only enable when needed:</p> <pre><code># Single-threaded: fast\nwired = Wiring(spec, thread_safe=False)\n\n# Multi-threaded: slight overhead\nwired = Wiring(spec, thread_safe=True)\n</code></pre>"},{"location":"user-guide/advanced/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete API documentation</li> <li>Examples - Practical examples and patterns</li> <li>Development - Contributing guide</li> </ul>"},{"location":"user-guide/async-support/","title":"Async Support","text":""},{"location":"user-guide/async-support/#async-support","title":"Async Support","text":"<p>apywire provides built-in support for asynchronous object access via the <code>AioAccessor</code> pattern.</p>"},{"location":"user-guide/async-support/#overview","title":"Overview","text":"<p>The <code>AioAccessor</code> allows you to access wired objects in async contexts using <code>await</code>. This is useful when:</p> <ul> <li>Your application is built with <code>asyncio</code></li> <li>You want to instantiate objects without blocking the event loop</li> <li>You're working with async frameworks like FastAPI, aiohttp, or Starlette</li> </ul>"},{"location":"user-guide/async-support/#basic-async-access","title":"Basic Async Access","text":"<p>Use the <code>.aio</code> attribute to get async accessors:</p> <pre><code>import asyncio\nfrom apywire import Wiring\n\nspec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\nasync def main():\n    wired = Wiring(spec)\n\n    # Async access\n    dt = await wired.aio.now()\n    print(dt)  # 2025-01-01 00:00:00\n\nasyncio.run(main())\n</code></pre> <p>This is especially useful for factory methods that perform I/O operations.</p>"},{"location":"user-guide/async-support/#how-it-works","title":"How It Works","text":"<p>When you use <code>.aio</code>, apywire wraps the object instantiation in an executor:</p> <pre><code># Under the hood (simplified)\nasync def aio_accessor():\n    loop = asyncio.get_running_loop()\n    return await loop.run_in_executor(None, sync_accessor)\n</code></pre> <p>This means:</p> <ol> <li>Object instantiation runs in a thread pool executor</li> <li>The async event loop is not blocked</li> <li>The object is still cached after first instantiation</li> </ol>"},{"location":"user-guide/async-support/#async-vs-sync-access","title":"Async vs Sync Access","text":""},{"location":"user-guide/async-support/#sync-access","title":"Sync Access","text":"<pre><code>wired = Wiring(spec)\nobj = wired.my_object()  # Synchronous, blocks until instantiated\n</code></pre>"},{"location":"user-guide/async-support/#async-access","title":"Async Access","text":"<pre><code>async def get_object():\n    wired = Wiring(spec)\n    obj = await wired.aio.my_object()  # Async, doesn't block event loop\n    return obj\n</code></pre>"},{"location":"user-guide/async-support/#caching-with-async","title":"Caching with Async","text":"<p>Just like sync access, async access caches objects:</p> <pre><code>async def main():\n    wired = Wiring(spec)\n\n    obj1 = await wired.aio.my_object()\n    obj2 = await wired.aio.my_object()\n\n    assert obj1 is obj2  # True - same cached instance!\n</code></pre> <p>You can even mix sync and async access - they share the same cache:</p> <pre><code>async def main():\n    wired = Wiring(spec)\n\n    obj1 = wired.my_object()  # Sync access\n    obj2 = await wired.aio.my_object()  # Async access\n\n    assert obj1 is obj2  # True - same object!\n</code></pre>"},{"location":"user-guide/async-support/#when-to-use-async-access","title":"When to Use Async Access","text":""},{"location":"user-guide/async-support/#use-async-access-when","title":"\u2705 Use Async Access When:","text":"<ul> <li>Working in async contexts (<code>async def</code> functions)</li> <li>Using async frameworks (FastAPI, aiohttp, etc.)</li> <li>Object instantiation might be slow and you don't want to block</li> <li>You want to instantiate multiple objects concurrently</li> </ul>"},{"location":"user-guide/async-support/#dont-use-async-access-when","title":"\u274c Don't Use Async Access When:","text":"<ul> <li>Working in sync code (use regular accessors instead)</li> <li>Object instantiation is very fast (overhead not worth it)</li> <li>You don't have an event loop running</li> </ul>"},{"location":"user-guide/async-support/#concurrent-instantiation","title":"Concurrent Instantiation","text":"<p>You can instantiate multiple objects concurrently:</p> <pre><code>import asyncio\nfrom apywire import Wiring\n\nspec = {\n    \"MyDatabase db1\": {\"host\": \"server1.example.com\"},\n    \"MyDatabase db2\": {\"host\": \"server2.example.com\"},\n    \"MyDatabase db3\": {\"host\": \"server3.example.com\"},\n}\n\nasync def main():\n    wired = Wiring(spec)\n\n    # Instantiate all three databases concurrently\n    db1, db2, db3 = await asyncio.gather(\n        wired.aio.db1(),\n        wired.aio.db2(),\n        wired.aio.db3(),\n    )\n\n    print(\"All databases ready!\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/async-support/#real-world-example-fastapi","title":"Real-World Example: FastAPI","text":"<pre><code>from fastapi import FastAPI, Depends\nfrom apywire import Wiring\n\nspec = {\n    \"database_url\": \"postgresql://localhost/mydb\",\n    \"redis_url\": \"redis://localhost\",\n\n    \"psycopg2.connect db\": {\"dsn\": \"{database_url}\"},\n    \"redis.Redis cache\": {\"url\": \"{redis_url}\"},\n    \"MyRepository repository\": {\"db\": \"{db}\"},\n}\n\n# Create wiring container at startup\nwired = Wiring(spec)\n\napp = FastAPI()\n\nasync def get_repository():\n    \"\"\"Dependency that provides the repository.\"\"\"\n    return await wired.aio.repository()\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, repo = Depends(get_repository)):\n    \"\"\"Get user by ID.\"\"\"\n    user = await repo.get_user(user_id)\n    return user\n</code></pre>"},{"location":"user-guide/async-support/#compiling-with-async-support","title":"Compiling with Async Support","text":"<p>When compiling your wiring spec to code, you can include async support:</p> <pre><code>from apywire import WiringCompiler\n\ncompiler = WiringCompiler(spec)\ncode = compiler.compile(aio=True)  # Include async accessors in generated code\n</code></pre> <p>The generated code will include both sync and async accessor methods.</p>"},{"location":"user-guide/async-support/#thread-safety-with-async","title":"Thread Safety with Async","text":"<p>If you're using async access in a multi-threaded environment (e.g., running multiple event loops in different threads), enable thread safety:</p> <pre><code>wired = Wiring(spec, thread_safe=True)\n\nasync def main():\n    obj = await wired.aio.my_object()  # Thread-safe async access\n</code></pre> <p>See Thread Safety for more details.</p>"},{"location":"user-guide/async-support/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user-guide/async-support/#overhead","title":"Overhead","text":"<p>Async access has a small overhead due to executor scheduling:</p> <pre><code>import time\n\nspec = {\n    \"datetime.datetime dt\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\nwired = Wiring(spec)\n\n# Sync access (very fast)\nstart = time.perf_counter()\n_ = wired.dt()\nsync_time = time.perf_counter() - start\n\n# Async access (slightly slower due to executor)\nasync def async_test():\n    start = time.perf_counter()\n    _ = await wired.aio.dt()\n    return time.perf_counter() - start\n\nasync_time = asyncio.run(async_test())\n\n# async_time will be slightly higher than sync_time\n</code></pre> <p>For lightweight objects, the overhead might not be worth it. Use async access when:</p> <ul> <li>Object instantiation involves I/O (database connections, file opening, etc.)</li> <li>You need to instantiate multiple objects concurrently</li> <li>You're already in an async context and want consistency</li> </ul>"},{"location":"user-guide/async-support/#caching-mitigates-overhead","title":"Caching Mitigates Overhead","text":"<p>Since objects are cached after first access, the overhead only applies to the first instantiation:</p> <pre><code>async def main():\n    wired = Wiring(spec)\n\n    # First access: pays executor overhead\n    obj1 = await wired.aio.my_object()\n\n    # Subsequent accesses: instant, no overhead\n    obj2 = await wired.aio.my_object()  # Cached!\n</code></pre>"},{"location":"user-guide/async-support/#error-handling","title":"Error Handling","text":"<p>Async access raises the same exceptions as sync access:</p> <pre><code>from apywire import UnknownPlaceholderError, CircularWiringError\n\nasync def main():\n    spec = {\n        \"MyClass obj\": {\"dep\": \"{nonexistent}\"},\n    }\n\n    wired = Wiring(spec)\n\n    try:\n        obj = await wired.aio.obj()\n    except UnknownPlaceholderError as e:\n        print(f\"Error: {e}\")\n</code></pre>"},{"location":"user-guide/async-support/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/async-support/#1-use-async-accessors-in-async-contexts","title":"1. Use Async Accessors in Async Contexts","text":"<pre><code># Good\nasync def setup():\n    wired = Wiring(spec)\n    db = await wired.aio.database()\n\n# Avoid - don't mix contexts unnecessarily\ndef setup():\n    wired = Wiring(spec)\n    db = asyncio.run(wired.aio.database())  # Awkward!\n</code></pre>"},{"location":"user-guide/async-support/#2-instantiate-dependencies-concurrently","title":"2. Instantiate Dependencies Concurrently","text":"<pre><code># Good - concurrent\nasync def setup():\n    wired = Wiring(spec)\n    db, cache, logger = await asyncio.gather(\n        wired.aio.database(),\n        wired.aio.cache(),\n        wired.aio.logger(),\n    )\n\n# Works but slower - sequential\nasync def setup():\n    wired = Wiring(spec)\n    db = await wired.aio.database()\n    cache = await wired.aio.cache()\n    logger = await wired.aio.logger()\n</code></pre>"},{"location":"user-guide/async-support/#3-dont-over-optimize","title":"3. Don't Over-Optimize","text":"<pre><code># Overkill for lightweight objects\nasync def get_datetime():\n    wired = Wiring({\"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1}})\n    dt = await wired.aio.now()  # Unnecessary async for simple object\n\n# Just use sync access for lightweight objects\ndef get_datetime():\n    wired = Wiring({\"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1}})\n    dt = wired.now()  # Better - no async overhead\n</code></pre>"},{"location":"user-guide/async-support/#next-steps","title":"Next Steps","text":"<ul> <li>Thread Safety - Combine async with thread safety</li> <li>Compilation - Generate async-capable code</li> <li>Basic Usage - Review sync accessor patterns</li> </ul>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":""},{"location":"user-guide/basic-usage/#basic-usage","title":"Basic Usage","text":"<p>This guide covers the fundamental usage patterns of apywire.</p>"},{"location":"user-guide/basic-usage/#creating-a-wiring-container","title":"Creating a Wiring Container","text":"<p>The <code>Wiring</code> class is the main entry point for dependency injection:</p> <pre><code>from apywire import Wiring\n\nspec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\nwired = Wiring(spec)\n</code></pre> <p>By default, <code>Wiring</code> creates a non-thread-safe container suitable for single-threaded applications. For thread safety, see the Thread Safety guide.</p>"},{"location":"user-guide/basic-usage/#defining-specs","title":"Defining Specs","text":"<p>The spec dictionary maps wiring keys to configuration. There are two types of entries:</p>"},{"location":"user-guide/basic-usage/#wired-objects","title":"Wired Objects","text":"<p>Use the format <code>\"module.Class name\"</code> to define objects that should be lazily instantiated:</p> <pre><code>spec = {\n    \"datetime.datetime start_time\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n    \"pathlib.Path project_root\": {0: \"/home/user/project\"},\n    \"MyClass service\": {\"param1\": \"value1\", \"param2\": 42},\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#constants","title":"Constants","text":"<p>Simple keys without the <code>module.Class</code> format become constants:</p> <pre><code>spec = {\n    \"host\": \"localhost\",\n    \"port\": 8080,\n    \"debug\": True,\n    \"api_key\": \"secret-key-here\",\n}\n\nwired = Wiring(spec)\n# Constants are primarily used as placeholder references in other wired objects\n</code></pre> <p>Note</p> <p>Constants are most useful as placeholder references for other wired objects using the <code>{name}</code> syntax.</p>"},{"location":"user-guide/basic-usage/#spec-value-types","title":"Spec Value Types","text":"<p>apywire supports various parameter types:</p>"},{"location":"user-guide/basic-usage/#keyword-arguments-dict","title":"Keyword Arguments (Dict)","text":"<pre><code>spec = {\n    \"datetime.datetime dt\": {\n        \"year\": 2025,\n        \"month\": 6,\n        \"day\": 15,\n        \"hour\": 10,\n    },\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#positional-arguments-list","title":"Positional Arguments (List)","text":"<pre><code>spec = {\n    \"pathlib.Path path\": [\"/home/user/project\"],\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#positional-arguments-numeric-dict-keys","title":"Positional Arguments (Numeric Dict Keys)","text":"<pre><code>spec = {\n    \"pathlib.Path path\": {0: \"/home\", 1: \"user\", 2: \"project\"},\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#mixed-arguments","title":"Mixed Arguments","text":"<p>You can combine positional and keyword arguments:</p> <pre><code>spec = {\n    \"MyClass obj\": {\n        0: \"positional_arg1\",\n        1: \"positional_arg2\",\n        \"keyword_arg\": \"value\",\n    },\n}\n</code></pre> <p>Numeric keys are sorted and passed as positional arguments, while string keys become keyword arguments.</p>"},{"location":"user-guide/basic-usage/#using-placeholders","title":"Using Placeholders","text":"<p>Reference other wired objects or constants using <code>{name}</code> syntax:</p> <pre><code>spec = {\n    \"database_url\": \"postgresql://localhost/mydb\",\n    \"max_connections\": 10,\n\n    \"psycopg2.pool.SimpleConnectionPool pool\": {\n        \"minconn\": 1,\n        \"maxconn\": \"{max_connections}\",\n        \"dsn\": \"{database_url}\",\n    },\n}\n\nwired = Wiring(spec)\npool = wired.pool()  # placeholders are resolved to actual values\n</code></pre>"},{"location":"user-guide/basic-usage/#nested-placeholders","title":"Nested Placeholders","text":"<p>Placeholders work in nested structures:</p> <pre><code>spec = {\n    \"api_key\": \"secret-key\",\n\n    \"MyClient client\": {\n        \"config\": {\n            \"auth\": {\n                \"api_key\": \"{api_key}\",  # Nested placeholder\n            },\n            \"timeout\": 30,\n        },\n    },\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#list-placeholders","title":"List Placeholders","text":"<p>Placeholders work in lists too:</p> <pre><code>spec = {\n    \"datetime.datetime start\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n    \"datetime.datetime end\": {\"year\": 2025, \"month\": 12, \"day\": 31},\n\n    \"MyReport report\": {\n        \"date_range\": [\"{start}\", \"{end}\"],  # List with placeholders\n    },\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#accessing-wired-objects","title":"Accessing Wired Objects","text":""},{"location":"user-guide/basic-usage/#the-accessor-pattern","title":"The Accessor Pattern","text":"<p>When you access an attribute on a <code>Wiring</code> container, you get an <code>Accessor</code>:</p> <pre><code>from apywire import Wiring, Accessor\n\nwired = Wiring(spec)\naccessor = wired.my_object  # Returns an Accessor instance\nprint(type(accessor))  # &lt;class 'apywire.runtime.Accessor'&gt;\n</code></pre> <p>Call the accessor to instantiate the object:</p> <pre><code>obj = accessor()  # Instantiates the object\n</code></pre> <p>Most commonly, you'll do both in one line:</p> <pre><code>obj = wired.my_object()\n</code></pre>"},{"location":"user-guide/basic-usage/#caching-behavior","title":"Caching Behavior","text":"<p>Objects are instantiated once and cached:</p> <pre><code>spec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\nwired = Wiring(spec)\n\ndt1 = wired.now()\ndt2 = wired.now()\n\nassert dt1 is dt2  # True - same object instance!\n</code></pre> <p>Each access returns the same instance, not a new one. This is crucial for:</p> <ul> <li>Maintaining singleton-like behavior</li> <li>Avoiding duplicate resource allocation (e.g., database connections)</li> <li>Ensuring consistent state across your application</li> </ul>"},{"location":"user-guide/basic-usage/#when-instantiation-happens","title":"When Instantiation Happens","text":"<pre><code>wired = Wiring(spec)\n# No objects instantiated yet!\n\naccessor = wired.my_object\n# Still nothing instantiated - just got the accessor\n\nobj = accessor()\n# NOW the object is created and cached\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-multiple-objects","title":"Working with Multiple Objects","text":"<pre><code>spec = {\n    \"datetime.datetime start\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n    \"datetime.timedelta delta\": {\"days\": 7},\n    \"pathlib.Path root\": [\"/home/user\"],\n}\n\nwired = Wiring(spec)\n\n# Access multiple objects\nstart_date = wired.start()\ntime_delta = wired.delta()\nroot_path = wired.root()\n</code></pre>"},{"location":"user-guide/basic-usage/#dependency-resolution-order","title":"Dependency Resolution Order","text":"<p>When accessing an object with placeholder dependencies, apywire resolves them in order:</p> <pre><code>spec = {\n    \"MyDatabase db\": {},\n    \"MyCache cache\": {\"db\": \"{db}\"},  # Depends on db\n    \"MyService service\": {\n        \"cache\": \"{cache}\",  # Depends on cache\n        \"db\": \"{db}\",        # Also depends on db\n    },\n}\n\nwired = Wiring(spec)\nservice = wired.service()\n# Resolution order: db \u2192 cache \u2192 service\n</code></pre> <p>apywire automatically handles the dependency graph and instantiates objects in the correct order.</p>"},{"location":"user-guide/basic-usage/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/basic-usage/#unknown-placeholder","title":"Unknown Placeholder","text":"<pre><code>from apywire import Wiring, UnknownPlaceholderError\n\nspec = {\n    \"MyClass obj\": {\"dependency\": \"{nonexistent}\"},\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.obj()\nexcept UnknownPlaceholderError as e:\n    print(f\"Unknown placeholder: {e}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#circular-dependencies","title":"Circular Dependencies","text":"<pre><code>from apywire import Wiring, CircularWiringError\n\nspec = {\n    \"MyClass a\": {\"dep\": \"{b}\"},\n    \"MyClass b\": {\"dep\": \"{a}\"},\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.a()\nexcept CircularWiringError as e:\n    print(f\"Circular dependency: {e}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#import-errors","title":"Import Errors","text":"<pre><code>spec = {\n    \"nonexistent.module.Class obj\": {},\n}\n\nwired = Wiring(spec)\ntry:\n    obj = wired.obj()\nexcept ImportError as e:\n    print(f\"Cannot import: {e}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/basic-usage/#1-use-descriptive-names","title":"1. Use Descriptive Names","text":"<pre><code># Good\nspec = {\n    \"psycopg2.connect db_connection\": {\"dsn\": \"{database_url}\"},\n    \"MyRepository user_repository\": {\"db\": \"{db_connection}\"},\n}\n\n# Avoid\nspec = {\n    \"psycopg2.connect conn\": {\"dsn\": \"{url}\"},\n    \"MyRepository repo\": {\"db\": \"{conn}\"},\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#2-group-related-objects","title":"2. Group Related Objects","text":"<pre><code>spec = {\n    # Database layer\n    \"db_url\": \"postgresql://localhost/mydb\",\n    \"psycopg2.connect db\": {\"dsn\": \"{db_url}\"},\n\n    # Cache layer\n    \"redis_url\": \"redis://localhost\",\n    \"redis.Redis cache\": {\"url\": \"{redis_url}\"},\n\n    # Service layer\n    \"MyService service\": {\"db\": \"{db}\", \"cache\": \"{cache}\"},\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#3-validate-configuration-early","title":"3. Validate Configuration Early","text":"<pre><code>def validate_wiring(wired: Wiring) -&gt; None:\n    \"\"\"Validate all wired objects can be instantiated.\"\"\"\n    # Access all objects to trigger any configuration errors\n    _ = wired.database()\n    _ = wired.cache()\n    _ = wired.service()\n\n# In your app startup\nwired = Wiring(spec)\nvalidate_wiring(wired)  # Fail fast if configuration is wrong\n</code></pre>"},{"location":"user-guide/basic-usage/#4-use-constants-for-configuration","title":"4. Use Constants for Configuration","text":"<pre><code>spec = {\n    # Configuration constants\n    \"debug\": True,\n    \"log_level\": \"INFO\",\n    \"timeout\": 30,\n\n    # Wired objects using configuration\n    \"logging.Logger logger\": {\n        \"name\": \"myapp\",\n        \"level\": \"{log_level}\",\n    },\n    \"MyClient client\": {\n        \"timeout\": \"{timeout}\",\n        \"debug\": \"{debug}\",\n    },\n}\n</code></pre>"},{"location":"user-guide/basic-usage/#5-keep-specs-testable","title":"5. Keep Specs Testable","text":"<pre><code># production_spec.py\ndef get_production_spec():\n    return {\n        \"psycopg2.connect db\": {\"dsn\": \"postgresql://prod/db\"},\n    }\n\n# test_spec.py\ndef get_test_spec():\n    return {\n        \"unittest.mock.Mock db\": {},  # Mock database for testing\n    }\n\n# Usage\nif os.getenv(\"TESTING\"):\n    wired = Wiring(get_test_spec())\nelse:\n    wired = Wiring(get_production_spec())\n</code></pre>"},{"location":"user-guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Async Support - Use <code>await wired.aio.name()</code> for async access</li> <li>Thread Safety - Enable thread-safe instantiation</li> <li>Compilation - Generate standalone code from your spec</li> <li>Advanced Features - Factory methods and complex patterns</li> </ul>"},{"location":"user-guide/cli/","title":"Command Line Interface","text":""},{"location":"user-guide/cli/#command-line-interface","title":"Command Line Interface","text":"<p>apywire provides a CLI for generating specs from class introspection and compiling specs to Python code.</p>"},{"location":"user-guide/cli/#installation","title":"Installation","text":"<p>The CLI is included with apywire:</p> <pre><code>pip install apywire\n</code></pre> <p>Verify the installation:</p> <pre><code>python -m apywire --version\n</code></pre>"},{"location":"user-guide/cli/#commands","title":"Commands","text":""},{"location":"user-guide/cli/#generate","title":"generate","text":"<p>Generate a wiring spec by introspecting class constructors.</p> <pre><code>python -m apywire generate --format FORMAT ENTRY [ENTRY ...]\n</code></pre> <p>Arguments:</p> <ul> <li><code>--format FORMAT</code> - Output format: <code>ini</code>, <code>toml</code>, or <code>json</code> (required)</li> <li><code>ENTRY</code> - One or more class entries as <code>module.Class name</code></li> </ul> <p>Examples:</p> <pre><code># Generate a spec for datetime.datetime\npython -m apywire generate --format json \"datetime.datetime now\"\n\n# Generate TOML and save to file\npython -m apywire generate --format toml \"datetime.datetime now\" &gt; config.toml\n\n# Multiple entries\npython -m apywire generate --format json \\\n    \"datetime.datetime now\" \\\n    \"collections.OrderedDict config\"\n</code></pre> <p>Output:</p> <p>The generator introspects the class constructor and creates placeholders for each parameter:</p> <pre><code>$ python -m apywire generate --format toml \"datetime.datetime now\"\n</code></pre> <pre><code>[\"datetime.datetime now\"]\nyear = \"{now_year}\"\nmonth = \"{now_month}\"\nday = \"{now_day}\"\n...\n</code></pre>"},{"location":"user-guide/cli/#compile","title":"compile","text":"<p>Compile a spec file to Python code.</p> <pre><code>python -m apywire compile --format FORMAT [--aio] [--thread-safe] FILE\n</code></pre> <p>Arguments:</p> <ul> <li><code>--format FORMAT</code> - Input format: <code>ini</code>, <code>toml</code>, or <code>json</code> (required)</li> <li><code>--aio</code> - Generate async accessors using <code>run_in_executor</code></li> <li><code>--thread-safe</code> - Generate thread-safe accessors with locking</li> <li><code>FILE</code> - Input spec file path, or <code>-</code> to read from stdin</li> </ul> <p>Examples:</p> <pre><code># Compile a JSON spec\npython -m apywire compile --format json config.json\n\n# Compile with async support\npython -m apywire compile --format toml --aio config.toml &gt; wiring.py\n\n# Compile with thread safety\npython -m apywire compile --format ini --thread-safe config.ini\n\n# Read from stdin\ncat config.json | python -m apywire compile --format json -\n</code></pre> <p>Output:</p> <p>The compiler generates a Python module with a <code>Compiled</code> class:</p> <pre><code>import datetime\n\nclass Compiled:\n\n    def now(self):\n        if not hasattr(self, '_now'):\n            self._now = datetime.datetime(year=self.now_year(), ...)\n        return self._now\n\n    def now_year(self):\n        return 2025\n\ncompiled = Compiled()\n</code></pre>"},{"location":"user-guide/cli/#full-workflow","title":"Full Workflow","text":"<p>A typical workflow combines generate and compile:</p>"},{"location":"user-guide/cli/#1-generate-a-spec","title":"1. Generate a Spec","text":"<pre><code>python -m apywire generate --format toml \"datetime.datetime now\" &gt; config.toml\n</code></pre>"},{"location":"user-guide/cli/#2-customize-the-spec","title":"2. Customize the Spec","text":"<p>Edit <code>config.toml</code> with your values:</p> <pre><code>now_year = 2025\nnow_month = 6\nnow_day = 15\n\n[\"datetime.datetime now\"]\nyear = \"{now_year}\"\nmonth = \"{now_month}\"\nday = \"{now_day}\"\n</code></pre>"},{"location":"user-guide/cli/#3-compile-to-python","title":"3. Compile to Python","text":"<pre><code>python -m apywire compile --format toml config.toml &gt; wiring.py\n</code></pre>"},{"location":"user-guide/cli/#4-use-in-your-application","title":"4. Use in Your Application","text":"<pre><code>from wiring import compiled\n\ndt = compiled.now()\nprint(f\"Date: {dt}\")  # Date: 2025-06-15 00:00:00\n</code></pre>"},{"location":"user-guide/cli/#pipeline-usage","title":"Pipeline Usage","text":"<p>You can pipe generate output directly to compile:</p> <pre><code># Generate and compile in one command\npython -m apywire generate --format json \"collections.OrderedDict cfg\" \\\n    | python -m apywire compile --format json -\n</code></pre>"},{"location":"user-guide/cli/#format-reference","title":"Format Reference","text":""},{"location":"user-guide/cli/#json","title":"JSON","text":"<p>Direct mapping\u2014no special handling needed:</p> <pre><code>{\n  \"collections.OrderedDict config\": {},\n  \"max_size\": 100\n}\n</code></pre>"},{"location":"user-guide/cli/#toml","title":"TOML","text":"<p>Top-level keys are constants, tables are wiring entries:</p> <pre><code>max_size = 100\n\n[\"collections.OrderedDict config\"]\n</code></pre> <p>Quoted Section Names</p> <p>TOML section names containing spaces must be quoted: <code>[\"module.Class name\"]</code></p>"},{"location":"user-guide/cli/#ini","title":"INI","text":"<p>Uses <code>[constants]</code> section for constants (required by INI format):</p> <pre><code>[constants]\nmax_size = 100\n\n[collections.OrderedDict config]\n</code></pre>"},{"location":"user-guide/cli/#compiler-options","title":"Compiler Options","text":""},{"location":"user-guide/cli/#-aio","title":"--aio","text":"<p>Generates async accessors that use <code>asyncio.run_in_executor</code>:</p> <pre><code>async def now(self):\n    if not hasattr(self, '_now'):\n        loop = asyncio.get_running_loop()\n        self._now = await loop.run_in_executor(None, lambda: datetime.datetime(...))\n    return self._now\n</code></pre>"},{"location":"user-guide/cli/#-thread-safe","title":"--thread-safe","text":"<p>Generates thread-safe accessors with locking:</p> <pre><code>class Compiled(ThreadSafeMixin):\n\n    def __init__(self):\n        self._init_thread_safety()\n\n    def now(self):\n        if not hasattr(self, '_now'):\n            self._now = self._instantiate_attr('now', lambda: datetime.datetime(...))\n        return self._now\n</code></pre> <p>You can combine both flags:</p> <pre><code>python -m apywire compile --format json --aio --thread-safe config.json\n</code></pre>"},{"location":"user-guide/cli/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Files - Loading specs from config files</li> <li>Compilation - Understanding the compiled output</li> <li>Generator - Python API for the generator</li> </ul>"},{"location":"user-guide/compilation/","title":"Compilation","text":""},{"location":"user-guide/compilation/#compilation","title":"Compilation","text":"<p>apywire can generate standalone Python code from your wiring spec using the <code>WiringCompiler</code> class and its <code>compile()</code> method. This is useful for production deployments and performance optimization.</p>"},{"location":"user-guide/compilation/#overview","title":"Overview","text":"<p>The <code>compile()</code> method generates Python code that behaves identically to the runtime <code>Wiring</code> container:</p> <pre><code>from apywire import WiringCompiler\n\nspec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\ncompiler = WiringCompiler(spec)\ncode = compiler.compile()\nprint(code)\n</code></pre> <p>This generates a Python class with the same lazy loading, caching, and dependency resolution behavior.</p>"},{"location":"user-guide/compilation/#basic-compilation","title":"Basic Compilation","text":"<pre><code>from apywire import WiringCompiler\n\nspec = {\n    \"datetime.datetime start\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n    \"datetime.timedelta delta\": {\"days\": 7},\n}\n\ncompiler = WiringCompiler(spec)\ncode = compiler.compile()\n\n# Save to file\nwith open(\"compiled_wiring.py\", \"w\") as f:\n    f.write(code)\n</code></pre> <p>The generated code can be imported and used like the runtime container:</p> <pre><code>from compiled_wiring import Compiled\n\nwired = Compiled()\nstart = wired.start()\ndelta = wired.delta()\n</code></pre>"},{"location":"user-guide/compilation/#compilation-options","title":"Compilation Options","text":""},{"location":"user-guide/compilation/#aio-async-support","title":"aio (Async Support)","text":"<p>Include async accessors in the generated code:</p> <pre><code>code = compiler.compile(aio=True)\n</code></pre> <p>Generated code will support both sync and async access:</p> <pre><code>from compiled_wiring import Compiled\n\nwired = Compiled()\n\n# Sync access\nobj = wired.my_object()\n\n# Async access\nimport asyncio\nobj = asyncio.run(wired.aio.my_object())\n</code></pre>"},{"location":"user-guide/compilation/#thread_safe-thread-safety","title":"thread_safe (Thread Safety)","text":"<p>Include thread-safe instantiation in the generated code:</p> <pre><code>code = compiler.compile(thread_safe=True)\n</code></pre> <p>Generated code will use the same optimistic locking mechanism as runtime <code>Wiring</code>.</p>"},{"location":"user-guide/compilation/#combined-options","title":"Combined Options","text":"<pre><code>code = compiler.compile(aio=True, thread_safe=True)\n</code></pre> <p>Generates code with both async support and thread safety.</p>"},{"location":"user-guide/compilation/#generated-code-structure","title":"Generated Code Structure","text":"<p>The compiled code contains:</p>"},{"location":"user-guide/compilation/#1-imports","title":"1. Imports","text":"<p>All necessary imports for the wired classes:</p> <pre><code>import datetime\nimport pathlib\n# ... other imports\n</code></pre>"},{"location":"user-guide/compilation/#2-the-compiled-class","title":"2. The Compiled Class","text":"<p>A class that mirrors your wiring spec:</p> <pre><code>class Compiled:\n    def __init__(self):\n        self._values = {}\n        # Thread-safe: locks initialization\n        # Constants initialization\n</code></pre>"},{"location":"user-guide/compilation/#3-accessor-methods","title":"3. Accessor Methods","text":"<p>Methods for each wired object:</p> <pre><code>def start(self):\n    if \"start\" not in self._values:\n        # Instantiation logic\n        self._values[\"start\"] = datetime.datetime(year=2025, month=1, day=1)\n    return self._values[\"start\"]\n</code></pre>"},{"location":"user-guide/compilation/#4-async-accessors-if-aiotrue","title":"4. Async Accessors (if aio=True)","text":"<p>Async versions of accessor methods:</p> <pre><code>class AioAccessors:\n    async def start(self):\n        loop = asyncio.get_running_loop()\n        return await loop.run_in_executor(None, lambda: self._wired.start())\n\n@property\ndef aio(self):\n    return self._aio_accessors\n</code></pre>"},{"location":"user-guide/compilation/#5-thread-safety-if-thread_safetrue","title":"5. Thread Safety (if thread_safe=True)","text":"<p>Locking mechanisms and thread-local state.</p>"},{"location":"user-guide/compilation/#why-compile","title":"Why Compile?","text":""},{"location":"user-guide/compilation/#benefits","title":"Benefits","text":"<ol> <li>Performance: Slightly faster than runtime <code>Wiring</code> (no dynamic <code>__getattr__</code> lookup)</li> <li>Deployment: No need to include spec dictionary in production code</li> <li>Type Checking: Generated code can be type-checked by mypy</li> <li>Inspection: Easier to understand dependency graph by reading generated code</li> <li>Cython: Can be compiled with Cython for additional performance</li> </ol>"},{"location":"user-guide/compilation/#trade-offs","title":"Trade-offs","text":"<ol> <li>Static: Can't modify spec at runtime</li> <li>Code Size: Generated code can be large for complex specs</li> <li>Maintenance: Need to regenerate if spec changes</li> </ol>"},{"location":"user-guide/compilation/#cython-compilation","title":"Cython Compilation","text":"<p>apywire itself uses Cython for performance. You can compile the generated code with Cython:</p>"},{"location":"user-guide/compilation/#step-1-generate-python-code","title":"Step 1: Generate Python Code","text":"<pre><code>compiler = WiringCompiler(spec)\ncode = compiler.compile()\nwith open(\"wiring.py\", \"w\") as f:\n    f.write(code)\n</code></pre>"},{"location":"user-guide/compilation/#step-2-create-setuppy","title":"Step 2: Create setup.py","text":"<pre><code>from setuptools import setup\nfrom Cython.Build import cythonize\n\nsetup(\n    ext_modules=cythonize(\"wiring.py\"),\n)\n</code></pre>"},{"location":"user-guide/compilation/#step-3-build","title":"Step 3: Build","text":"<pre><code>python setup.py build_ext --inplace\n</code></pre> <p>This generates <code>wiring.c</code> and <code>wiring.so</code> (compiled extension).</p>"},{"location":"user-guide/compilation/#real-world-example","title":"Real-World Example","text":""},{"location":"user-guide/compilation/#development-use-runtime-wiring","title":"Development: Use Runtime Wiring","text":"<pre><code># config.py\nfrom apywire import Wiring\n\ndef get_spec():\n    return {\n        \"database_url\": \"postgresql://localhost/mydb\",\n        \"psycopg2.connect db\": {\"dsn\": \"{database_url}\"},\n        \"MyRepository repo\": {\"db\": \"{db}\"},\n    }\n\nwired = Wiring(get_spec())\n</code></pre>"},{"location":"user-guide/compilation/#production-use-compiled-code","title":"Production: Use Compiled Code","text":"<pre><code># generate_wiring.py\nfrom apywire import WiringCompiler\nfrom config import get_spec\n\ncompiler = WiringCompiler(get_spec())\ncode = compiler.compile(aio=True, thread_safe=True)\n\nwith open(\"compiled_wiring.py\", \"w\") as f:\n    f.write(code)\n\nprint(\"Compiled wiring generated!\")\n</code></pre> <p>Run once during deployment:</p> <pre><code>python generate_wiring.py\n</code></pre> <p>Use in production:</p> <pre><code># app.py\nfrom compiled_wiring import Compiled\n\nwired = Compiled()\nrepo = wired.repo()\n</code></pre>"},{"location":"user-guide/compilation/#inspecting-generated-code","title":"Inspecting Generated Code","text":"<p>The generated code is readable Python. You can inspect it to understand dependencies:</p> <pre><code>spec = {\n    \"MyDatabase db\": {},\n    \"MyCache cache\": {\"db\": \"{db}\"},\n    \"MyService service\": {\"cache\": \"{cache}\"},\n}\n\ncompiler = WiringCompiler(spec)\ncode = compiler.compile()\n\n# Save and inspect\nwith open(\"wiring.py\", \"w\") as f:\n    f.write(code)\n\n# Look at wiring.py to see:\n# - service() method calls cache()\n# - cache() method calls db()\n# - Dependency chain is explicit\n</code></pre>"},{"location":"user-guide/compilation/#licensing-and-headers","title":"Licensing and Headers","text":"<p>The generated code doesn't include SPDX headers by default. Add them manually if needed:</p> <pre><code>header = \"\"\"# SPDX-FileCopyrightText: 2025 Your Name &lt;your@email.com&gt;\n#\n# SPDX-License-Identifier: ISC\n\n\"\"\"\n\ncompiler = WiringCompiler(spec)\ncode = compiler.compile()\nfull_code = header + code\n\nwith open(\"wiring.py\", \"w\") as f:\n    f.write(full_code)\n</code></pre>"},{"location":"user-guide/compilation/#testing-compiled-code","title":"Testing Compiled Code","text":"<p>Test that compiled code behaves identically to runtime:</p> <pre><code>from apywire import Wiring\n\nspec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\n# Runtime\nwired_runtime = Wiring(spec)\n\n# Compiled\ncompiler = WiringCompiler(spec)\ncode = compiler.compile()\nexec(code)  # Defines Compiled class\nwired_compiled = Compiled()\n\n# Both should produce same results\nassert wired_runtime.now() == wired_compiled.now()\n</code></pre>"},{"location":"user-guide/compilation/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/compilation/#1-generate-during-builddeploy","title":"1. Generate During Build/Deploy","text":"<pre><code># In your CI/CD pipeline\npython scripts/generate_wiring.py\npython setup.py build_ext --inplace  # Optional: Cython compile\n</code></pre>"},{"location":"user-guide/compilation/#2-version-control-generated-code","title":"2. Version Control Generated Code","text":"<p>Option A: Don't commit generated code (regenerate on deploy)</p> <pre><code># .gitignore\ncompiled_wiring.py\n</code></pre> <p>Option B: Commit generated code (easier for others to use)</p> <p>Pros: Others can use without regenerating Cons: Diffs in PRs, risk of forgetting to regenerate</p>"},{"location":"user-guide/compilation/#3-validate-generated-code","title":"3. Validate Generated Code","text":"<pre><code># In your tests\ndef test_compiled_code_valid():\n    from apywire import WiringCompiler\n\n    compiler = WiringCompiler(spec)\n    code = compiler.compile()\n\n    # Check code compiles\n    compile(code, \"wiring.py\", \"exec\")\n\n    # Check code executes\n    exec(code)\n</code></pre>"},{"location":"user-guide/compilation/#4-use-same-options-as-runtime","title":"4. Use Same Options as Runtime","text":"<p>If you use <code>thread_safe=True</code> in runtime, compile with it too:</p> <pre><code># Development\nwired = Wiring(spec, thread_safe=True)\n\n# Production\ncompiler = WiringCompiler(spec)\ncode = compiler.compile(thread_safe=True)  # Match!\n</code></pre>"},{"location":"user-guide/compilation/#debugging-generated-code","title":"Debugging Generated Code","text":"<p>If generated code has issues:</p>"},{"location":"user-guide/compilation/#1-save-to-file-and-inspect","title":"1. Save to File and Inspect","text":"<pre><code>code = compiler.compile()\nwith open(\"debug_wiring.py\", \"w\") as f:\n    f.write(code)\n\n# Open debug_wiring.py in your editor\n</code></pre>"},{"location":"user-guide/compilation/#2-check-for-syntax-errors","title":"2. Check for Syntax Errors","text":"<pre><code>try:\n    compile(code, \"wiring.py\", \"exec\")\nexcept SyntaxError as e:\n    print(f\"Syntax error in generated code: {e}\")\n</code></pre>"},{"location":"user-guide/compilation/#3-test-imports","title":"3. Test Imports","text":"<p>Make sure all modules in your spec can be imported:</p> <pre><code>spec = {\n    \"my.custom.module.Class obj\": {},\n}\n\n# Make sure my.custom.module is importable!\nimport my.custom.module\n</code></pre>"},{"location":"user-guide/compilation/#limitations","title":"Limitations","text":""},{"location":"user-guide/compilation/#1-dynamic-specs-not-supported","title":"1. Dynamic Specs Not Supported","text":"<p>Compilation is static. If your spec changes at runtime, you can't use compilation:</p> <pre><code># This won't work with compilation\nspec = {}\nif os.getenv(\"PRODUCTION\"):\n    spec[\"db\"] = {...}\nelse:\n    spec[\"db\"] = {...}  # Different spec!\n</code></pre>"},{"location":"user-guide/compilation/#2-lambda-functions","title":"2. Lambda Functions","text":"<p>Specs with lambdas can't be compiled:</p> <pre><code>spec = {\n    \"MyClass obj\": {\"callback\": lambda x: x * 2},  # Can't compile!\n}\n</code></pre>"},{"location":"user-guide/compilation/#3-complex-objects","title":"3. Complex Objects","text":"<p>Some Python objects can't be represented as code literals:</p> <pre><code>import re\n\nspec = {\n    \"regex\": re.compile(r\"\\d+\"),  # Can't compile!\n}\n</code></pre> <p>For these cases, use constants in the compiled code or factory functions.</p>"},{"location":"user-guide/compilation/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - Understand runtime wiring first</li> <li>Thread Safety - Learn about thread-safe compilation</li> <li>Async Support - Learn about async compilation</li> <li>Advanced Features - Advanced patterns and edge cases</li> </ul>"},{"location":"user-guide/configuration-files/","title":"Configuration Files","text":""},{"location":"user-guide/configuration-files/#configuration-files","title":"Configuration Files","text":"<p>apywire supports loading specs from JSON, TOML, and INI configuration files. The <code>apywire.formats</code> module provides utilities for parsing and serializing specs in these formats.</p>"},{"location":"user-guide/configuration-files/#why-use-configuration-files","title":"Why Use Configuration Files?","text":"<ul> <li>Separation of Concerns: Keep configuration separate from code</li> <li>Environment-Specific: Different configs for dev, staging, production</li> <li>Version Control: Track configuration changes</li> <li>Non-Developers: Allow non-programmers to modify configuration</li> <li>CLI Workflow: Generate specs with CLI, edit, then compile</li> </ul>"},{"location":"user-guide/configuration-files/#quick-start-with-cli","title":"Quick Start with CLI","text":"<p>The fastest way to create a configuration file is using the CLI:</p> <pre><code># Generate a spec from class introspection\npython -m apywire generate --format toml \"datetime.datetime now\" &gt; config.toml\n\n# Edit config.toml to customize values, then compile\npython -m apywire compile --format toml config.toml &gt; wiring.py\n</code></pre> <p>See Command Line Interface for full CLI documentation.</p>"},{"location":"user-guide/configuration-files/#supported-formats","title":"Supported Formats","text":""},{"location":"user-guide/configuration-files/#json","title":"JSON","text":"<p>JSON provides direct mapping with no conversion needed.</p> <p>Example: <code>config.json</code></p> <pre><code>{\n  \"database_url\": \"postgresql://localhost/mydb\",\n  \"pool_size\": 20,\n\n  \"myapp.Database db\": {\n    \"url\": \"{database_url}\",\n    \"pool_size\": \"{pool_size}\"\n  }\n}\n</code></pre> <p>Loading:</p> <pre><code>from apywire import Wiring\nfrom apywire.formats import json_to_spec\n\nwith open(\"config.json\") as f:\n    spec = json_to_spec(f.read())\n\nwired = Wiring(spec)\ndb = wired.db()\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Built into Python standard library</li> <li>\u2705 Universal format</li> <li>\u2705 No conversion needed</li> <li>\u274c No comments</li> </ul>"},{"location":"user-guide/configuration-files/#toml","title":"TOML","text":"<p>TOML is Python-friendly with top-level keys as constants and tables as wiring entries.</p> <p>Example: <code>config.toml</code></p> <pre><code># Constants as top-level keys\ndatabase_url = \"postgresql://localhost/mydb\"\npool_size = 20\n\n# Wiring entries as tables (quote names with spaces)\n[\"myapp.Database db\"]\nurl = \"{database_url}\"\npool_size = \"{pool_size}\"\n</code></pre> <p>Quoted Section Names</p> <p>TOML section names with spaces must be quoted: <code>[\"module.Class name\"]</code></p> <p>Loading:</p> <pre><code>from apywire import Wiring\nfrom apywire.formats import toml_to_spec\n\nwith open(\"config.toml\") as f:\n    spec = toml_to_spec(f.read())\n\nwired = Wiring(spec)\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Built into Python 3.11+ (<code>tomllib</code>)</li> <li>\u2705 Supports comments</li> <li>\u2705 Type-safe (integers, booleans, etc.)</li> <li>\u2705 Clean syntax for nested structures</li> </ul>"},{"location":"user-guide/configuration-files/#ini","title":"INI","text":"<p>INI uses a <code>[constants]</code> section for constants (required by the format).</p> <p>Example: <code>config.ini</code></p> <pre><code>[constants]\ndatabase_url = postgresql://localhost/mydb\npool_size = 20\n\n[myapp.Database db]\nurl = {database_url}\npool_size = {pool_size}\n</code></pre> <p>Loading:</p> <pre><code>from apywire import Wiring\nfrom apywire.formats import ini_to_spec\n\nwith open(\"config.ini\") as f:\n    spec = ini_to_spec(f.read())\n\nwired = Wiring(spec)\n</code></pre> <p>Benefits:</p> <ul> <li>\u2705 Built into Python standard library</li> <li>\u2705 Simple syntax</li> <li>\u2705 Supports comments</li> <li>\u274c All values are strings (automatic type conversion provided)</li> </ul>"},{"location":"user-guide/configuration-files/#yaml","title":"YAML","text":"<p>YAML is not directly supported by the formats module, but you can use PyYAML:</p> <pre><code>import yaml\nfrom apywire import Wiring\n\nwith open(\"config.yaml\") as f:\n    spec = yaml.safe_load(f)\n\nwired = Wiring(spec)\n</code></pre>"},{"location":"user-guide/configuration-files/#format-conversion","title":"Format Conversion","text":"<p>The formats module provides functions to convert between formats:</p> <pre><code>from apywire.formats import (\n    json_to_spec, spec_to_json,\n    toml_to_spec, spec_to_toml,\n    ini_to_spec, spec_to_ini,\n)\n\n# Load from one format\nwith open(\"config.json\") as f:\n    spec = json_to_spec(f.read())\n\n# Save to another format\ntoml_output = spec_to_toml(spec)\nwith open(\"config.toml\", \"w\") as f:\n    f.write(toml_output)\n</code></pre>"},{"location":"user-guide/configuration-files/#placeholder-expansion","title":"Placeholder Expansion","text":"<p>Constants can reference other constants and wired objects using <code>{name}</code> syntax.</p>"},{"location":"user-guide/configuration-files/#constant-constant","title":"Constant \u2192 Constant","text":"<p>When a constant references only other constants, it's expanded immediately:</p> <pre><code>host = \"localhost\"\nport = 5432\ndatabase_url = \"postgresql://{host}:{port}/mydb\"\n</code></pre>"},{"location":"user-guide/configuration-files/#constant-wired-object","title":"Constant \u2192 Wired Object","text":"<p>When a constant references a wired object, it becomes a lazy accessor:</p> <pre><code>[\"datetime.datetime server_start\"]\nyear = 2025\nmonth = 1\nday = 1\n\n# This is auto-promoted to an accessor\nstatus = \"Server started at {server_start}\"\n</code></pre> <pre><code>wired = Wiring(spec)\nmsg = wired.status()  # \"Server started at 2025-01-01 00:00:00\"\n</code></pre>"},{"location":"user-guide/configuration-files/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>Load different configs based on environment:</p> <pre><code>import os\nfrom apywire import Wiring\nfrom apywire.formats import toml_to_spec\n\nenv = os.getenv(\"APP_ENV\", \"dev\")\nconfig_file = f\"config.{env}.toml\"\n\nwith open(config_file) as f:\n    spec = toml_to_spec(f.read())\n\nwired = Wiring(spec, thread_safe=(env == \"production\"))\n</code></pre>"},{"location":"user-guide/configuration-files/#environment-variables","title":"Environment Variables","text":"<p>You can substitute environment variables before parsing:</p> <pre><code>import os\nimport re\nfrom apywire import Wiring\nfrom apywire.formats import toml_to_spec\n\ndef substitute_env(content: str) -&gt; str:\n    \"\"\"Replace ${VAR} with environment variable values.\"\"\"\n    return re.sub(\n        r'\\$\\{([^}]+)\\}',\n        lambda m: os.getenv(m.group(1), ''),\n        content\n    )\n\nwith open(\"config.toml\") as f:\n    content = substitute_env(f.read())\n    spec = toml_to_spec(content)\n\nwired = Wiring(spec)\n</code></pre>"},{"location":"user-guide/configuration-files/#complete-example","title":"Complete Example","text":""},{"location":"user-guide/configuration-files/#project-structure","title":"Project Structure","text":"<pre><code>myapp/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 dev.toml\n\u2502   \u251c\u2500\u2500 production.toml\n\u2502   \u2514\u2500\u2500 config.example.toml\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u2514\u2500\u2500 main.py\n\u2514\u2500\u2500 wiring.py  # Generated via CLI\n</code></pre>"},{"location":"user-guide/configuration-files/#configdevtoml","title":"<code>config/dev.toml</code>","text":"<pre><code>debug = true\ndatabase_url = \"postgresql://localhost/myapp_dev\"\npool_size = 5\n\n[\"myapp.Database db\"]\nurl = \"{database_url}\"\npool_size = \"{pool_size}\"\n\n[\"myapp.Cache cache\"]\nbackend = \"memory\"\n</code></pre>"},{"location":"user-guide/configuration-files/#appconfigpy","title":"<code>app/config.py</code>","text":"<pre><code>import os\nfrom pathlib import Path\nfrom apywire import Wiring\nfrom apywire.formats import toml_to_spec\n\ndef load_wiring() -&gt; Wiring:\n    env = os.getenv(\"APP_ENV\", \"dev\")\n    config_dir = Path(__file__).parent.parent / \"config\"\n    config_file = config_dir / f\"{env}.toml\"\n\n    with open(config_file) as f:\n        spec = toml_to_spec(f.read())\n\n    return Wiring(spec, thread_safe=(env == \"production\"))\n</code></pre>"},{"location":"user-guide/configuration-files/#appmainpy","title":"<code>app/main.py</code>","text":"<pre><code>from app.config import load_wiring\n\ndef main():\n    wired = load_wiring()\n    db = wired.db()\n    cache = wired.cache()\n    # Use services...\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"user-guide/configuration-files/#best-practices","title":"Best Practices","text":"<ol> <li>Keep Secrets Out: Use environment variables for passwords and API keys</li> <li>Separate Configs: Use different files for dev/staging/production</li> <li>Document Your Config: Include a <code>config.example.toml</code> in version control</li> <li>Validate Early: Check required keys before creating Wiring instance</li> </ol>"},{"location":"user-guide/configuration-files/#next-steps","title":"Next Steps","text":"<ul> <li>Command Line Interface - Generate and compile specs</li> <li>Basic Usage - Learn the fundamentals</li> <li>Compilation - Understanding compiled output</li> </ul>"},{"location":"user-guide/generator/","title":"Generator","text":""},{"location":"user-guide/generator/#generator-spec-generator","title":"Generator (Spec Generator)","text":"<p>The Generator utility can create apywire specs by introspecting class constructors. It is useful for scaffolding a spec quickly for use with <code>Wiring</code> in tests or when bootstrapping an application.</p>"},{"location":"user-guide/generator/#overview","title":"Overview","text":"<p><code>Generator</code> inspects the constructor signature (or a class factory method) and generates a spec entry for the given type and instance name. For each constructor parameter it creates:</p> <ul> <li>A placeholder for the parameter, e.g. <code>{instance_param}</code></li> <li>A constant default value in the spec based on the parameter's type (when available)</li> <li>Or a recursive dependency entry if the parameter is another class type</li> </ul> <p>The main entry point is <code>Generator.generate(*entries)</code>.</p>"},{"location":"user-guide/generator/#usage","title":"Usage","text":"<p>Basic usage:</p> <pre><code>from apywire import Generator, Wiring\n\nspec = Generator.generate(\"datetime.datetime now\")\nwired = Wiring(spec)\nnow = wired.now()\n</code></pre> <p>You can generate multiple entries in a single call:</p> <pre><code>spec = Generator.generate(\n  \"myapp.models.DateClass dt\",\n  \"myapp.models.DeltaClass delta\",\n)\n\n# Example output (spec dictionary):\nexpected_spec = {\n  \"myapp.models.DateClass dt\": {\n    \"month\": \"{dt_month}\",\n    \"year\": \"{dt_year}\",\n  },\n  \"myapp.models.DeltaClass delta\": {\n    \"days\": \"{delta_days}\",\n  },\n  \"dt_month\": 0,\n  \"dt_year\": 0,\n  \"delta_days\": 0,\n}\n</code></pre> <p>Factory methods are supported by adding the factory method to the entry string:</p> <pre><code># Class with @classmethod create(cls, x) -&gt; Instance\nspec = Generator.generate(\"myapp.factories.WithFactory obj.create\")\n\n# Example output (spec dictionary):\nexpected_spec = {\n  \"myapp.factories.WithFactory obj.create\": {\n    \"x\": \"{obj_x}\",\n  },\n  \"obj_x\": 0,\n}\n</code></pre>"},{"location":"user-guide/generator/#behavior-and-examples","title":"Behavior and Examples","text":"<ul> <li>Parameter names are converted into placeholders using the instance name:   a parameter <code>year</code> on instance <code>now</code> becomes placeholder <code>{now_year}</code>.</li> <li>Primitive and common types receive a sensible constant default:</li> <li><code>int</code>: 0, <code>float</code>: 0.0, <code>str</code>: \"\", <code>bool</code>: False, <code>bytes</code>: b\"\",     <code>complex</code>: 0j, <code>None</code>: None</li> <li><code>Optional[T]</code> (i.e., <code>Union[T, None]</code>) is resolved to the default for <code>T</code>.</li> <li>Complex unions default to <code>None</code>.</li> <li><code>list</code>, <code>dict</code>, <code>tuple</code> defaults are <code>[]</code>, <code>{}</code>, and <code>()</code> respectively.</li> <li>Unknown or missing annotations default to <code>None</code>.</li> <li>Non-constant parameter defaults (e.g. object instances) fall back to type defaults.</li> <li>Dependencies (constructor parameters typed as another class) are generated   recursively as separate spec entries, unless importing the dependency fails.</li> <li>Circular dependencies may raise <code>apywire.CircularWiringError</code> or generate partial   specs (tests consider both outcomes acceptable).</li> <li>Built-in types or types whose signatures cannot be inspected may result in an   empty <code>{}</code> entry for that wiring key.</li> </ul> <p>Example: Simple class</p> <pre><code>class Simple:\n    def __init__(self, year: int, month: int, day: int) -&gt; None:\n        ...\n\nspec = Generator.generate(\"myapp.models.Simple now\")\n\n# Example output (spec dictionary):\nexpected_spec = {\n    \"myapp.models.Simple now\": {\n        \"year\": \"{now_year}\",\n        \"month\": \"{now_month}\",\n        \"day\": \"{now_day}\",\n    },\n    \"now_year\": 0,\n    \"now_month\": 0,\n    \"now_day\": 0,\n}\n</code></pre> <p>Example: Dependency resolution</p> <pre><code>class Inner:\n    def __init__(self, value: int) -&gt; None: ...\n\nclass Outer:\n    def __init__(self, inner: Inner) -&gt; None: ...\n\nspec = Generator.generate(\"myapp.models.Outer wrapper\")\n\n# Example output (spec dictionary):\nexpected_spec = {\n  \"myapp.models.Inner wrapper_inner\": {\n    \"value\": \"{wrapper_inner_value}\",\n  },\n  \"myapp.models.Outer wrapper\": {\n    \"inner\": \"{wrapper_inner}\",\n  },\n  \"wrapper_inner_value\": 0,\n}\n</code></pre> <p>Example: Typed parameters</p> <pre><code>class TypedClass:\n    def __init__(\n        self,\n        int_param: int,\n        str_param: str,\n        float_param: float,\n        bool_param: bool,\n        opt_param: \"Optional[str]\" = None,\n    ) -&gt; None:\n        pass\n\nspec = Generator.generate(\"myapp.types.TypedClass obj\")\n\n# Example output (spec dictionary):\nexpected_spec = {\n  \"myapp.types.TypedClass obj\": {\n    \"int_param\": \"{obj_int_param}\",\n    \"str_param\": \"{obj_str_param}\",\n    \"float_param\": \"{obj_float_param}\",\n    \"bool_param\": \"{obj_bool_param}\",\n    \"opt_param\": \"{obj_opt_param}\",\n  },\n  \"obj_int_param\": 0,\n  \"obj_str_param\": \"\",\n  \"obj_float_param\": 0.0,\n  \"obj_bool_param\": False,\n  \"obj_opt_param\": None,\n}\n</code></pre> <p>Example: Constant defaults preserved</p> <pre><code>class WithDefaults:\n    def __init__(self, name: str = \"default_name\", count: int = 100) -&gt; None:\n        pass\n\nspec = Generator.generate(\"myapp.defaults.WithDefaults obj\")\n\n# Example output (spec dictionary):\nexpected_spec = {\n  \"myapp.defaults.WithDefaults obj\": {\n    \"count\": \"{obj_count}\",\n    \"name\": \"{obj_name}\",\n  },\n  \"obj_count\": 100,\n  \"obj_name\": \"default_name\",\n}\n</code></pre> <p>Example: List and dict types</p> <pre><code>class Container:\n    def __init__(self, items: \"List[int]\", mapping: \"Dict[str, int]\") -&gt; None:\n        pass\n\nspec = Generator.generate(\"myapp.containers.Container c\")\n\n# Example output (spec dictionary):\nexpected_spec = {\n  \"myapp.containers.Container c\": {\n    \"items\": \"{c_items}\",\n    \"mapping\": \"{c_mapping}\",\n  },\n  \"c_items\": [],\n  \"c_mapping\": {},\n}\n</code></pre>"},{"location":"user-guide/generator/#api","title":"API","text":""},{"location":"user-guide/generator/#generatorgenerateentries-str-apywirespec","title":"Generator.generate(*entries: str) -&gt; apywire.Spec","text":"<p>Arguments: - <code>entries</code>: Strings in the format <code>module.Class name</code> or   <code>module.Class name.factoryMethod</code>.</p> <p>Returns: - A <code>Spec</code> dictionary ready for <code>Wiring</code>.</p> <p>Raises: - <code>ValueError</code> for invalid entry strings (e.g., missing delimiter or module) - <code>apywire.exceptions.CircularWiringError</code> when a cycle is detected</p>"},{"location":"user-guide/generator/#notes-and-limitations","title":"Notes and Limitations","text":"<ul> <li>The generator bases decisions on constructor type annotations; without them   the generator cannot reliably infer dependencies and will use <code>None</code>.</li> <li>For classes that use complex, programmatic defaults or runtime logic, the   generator provides initial defaults but you should always review and adjust   generated specs to fit runtime requirements.</li> <li>The generated spec is a suggestion and can be altered before passing to   <code>Wiring</code>. It's useful for tests and bootstrapping but not intended to fully   replace manual configuration in production.</li> </ul>"},{"location":"user-guide/generator/#see-also","title":"See Also","text":"<ul> <li><code>Wiring</code> (docs/user-guide/basic-usage.md)</li> <li><code>apywire.Compiler</code> and the compiled wiring docs (user-guide/compilation.md)</li> </ul>"},{"location":"user-guide/thread-safety/","title":"Thread Safety","text":""},{"location":"user-guide/thread-safety/#thread-safety","title":"Thread Safety","text":"<p>apywire provides optional thread-safe instantiation for multi-threaded applications using optimistic locking.</p>"},{"location":"user-guide/thread-safety/#overview","title":"Overview","text":"<p>By default, <code>Wiring</code> containers are not thread-safe. This is intentional - thread safety has overhead, and many applications don't need it.</p> <p>For multi-threaded applications, enable thread safety:</p> <pre><code>from apywire import Wiring\n\nwired = Wiring(spec, thread_safe=True)\n</code></pre>"},{"location":"user-guide/thread-safety/#when-to-enable-thread-safety","title":"When to Enable Thread Safety","text":""},{"location":"user-guide/thread-safety/#enable-thread-safety-when","title":"\u2705 Enable Thread Safety When:","text":"<ul> <li>Running a multi-threaded web server (e.g., Gunicorn with multiple workers using threads)</li> <li>Sharing a <code>Wiring</code> container across multiple threads</li> <li>Instantiating objects from multiple concurrent threads</li> </ul>"},{"location":"user-guide/thread-safety/#dont-enable-thread-safety-when","title":"\u274c Don't Enable Thread Safety When:","text":"<ul> <li>Using async/await with a single event loop (use async, not threads)</li> <li>Single-threaded applications</li> <li>Each thread has its own <code>Wiring</code> container instance</li> </ul> <p>Rule of thumb: If you're not sure if you need thread-safe containers, you probably don't need them.</p>"},{"location":"user-guide/thread-safety/#how-it-works","title":"How It Works","text":"<p>apywire uses a two-level locking strategy:</p>"},{"location":"user-guide/thread-safety/#1-optimistic-per-attribute-locking","title":"1. Optimistic Per-Attribute Locking","text":"<p>Each wired attribute has its own lock. When accessing an object:</p> <ol> <li>Try to acquire the attribute-specific lock</li> <li>If acquired, instantiate the object and cache it</li> <li>Release the lock</li> </ol> <p>This minimizes contention - different threads can instantiate different objects simultaneously.</p> <pre><code># Thread 1 accessing wired.db()\n# Thread 2 accessing wired.cache()\n# These can happen concurrently - different locks!\n</code></pre>"},{"location":"user-guide/thread-safety/#2-global-fallback-locking","title":"2. Global Fallback Locking","text":"<p>If a thread can't acquire an attribute lock (contention), it falls back to a global lock with retries:</p> <ol> <li>Try to acquire the global lock</li> <li>Retry with exponential backoff</li> <li>If max retries exceeded, raise <code>LockUnavailableError</code></li> </ol> <p>This handles high-contention scenarios gracefully.</p>"},{"location":"user-guide/thread-safety/#configuration-options","title":"Configuration Options","text":""},{"location":"user-guide/thread-safety/#max_lock_attempts","title":"max_lock_attempts","text":"<p>Maximum number of retry attempts when falling back to global lock:</p> <pre><code>wired = Wiring(spec, thread_safe=True, max_lock_attempts=20)  # Default: 10\n</code></pre> <p>Higher values mean more retries before giving up, but longer potential waiting.</p>"},{"location":"user-guide/thread-safety/#lock_retry_sleep","title":"lock_retry_sleep","text":"<p>Sleep duration (in seconds) between retry attempts:</p> <pre><code>wired = Wiring(spec, thread_safe=True, lock_retry_sleep=0.005)  # Default: 0.01\n</code></pre> <p>Lower values mean faster retries, but more CPU usage. Higher values reduce CPU but increase latency.</p>"},{"location":"user-guide/thread-safety/#basic-usage","title":"Basic Usage","text":"<pre><code>import threading\nfrom apywire import Wiring\n\nspec = {\n    \"datetime.datetime now\": {\"year\": 2025, \"month\": 1, \"day\": 1},\n}\n\nwired = Wiring(spec, thread_safe=True)\n\ndef worker():\n    dt = wired.now()  # Thread-safe access\n    print(f\"Thread {threading.current_thread().name}: {dt}\")\n\n# Create multiple threads\nthreads = [threading.Thread(target=worker) for _ in range(10)]\n\n# Start all threads\nfor t in threads:\n    t.start()\n\n# Wait for completion\nfor t in threads:\n    t.join()\n\n# All threads get the same cached instance\n</code></pre>"},{"location":"user-guide/thread-safety/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/thread-safety/#lockunavailableerror","title":"LockUnavailableError","text":"<p>Raised when maximum lock retry attempts are exceeded:</p> <pre><code>from apywire import LockUnavailableError\n\nwired = Wiring(spec, thread_safe=True, max_lock_attempts=1)\n\ntry:\n    obj = wired.my_object()\nexcept LockUnavailableError as e:\n    print(f\"Could not acquire lock: {e}\")\n</code></pre> <p>In practice, this is rare and usually indicates:</p> <ul> <li>Extremely high contention</li> <li><code>max_lock_attempts</code> set too low</li> <li>A deadlock or very slow instantiation</li> </ul>"},{"location":"user-guide/thread-safety/#performance-implications","title":"Performance Implications","text":"<p>Thread safety has overhead:</p>"},{"location":"user-guide/thread-safety/#non-thread-safe-faster","title":"Non-Thread-Safe (Faster)","text":"<pre><code>wired = Wiring(spec, thread_safe=False)  # Default\nobj = wired.my_object()  # No locking overhead\n</code></pre>"},{"location":"user-guide/thread-safety/#thread-safe-slower","title":"Thread-Safe (Slower)","text":"<pre><code>wired = Wiring(spec, thread_safe=True)\nobj = wired.my_object()  # Lock acquisition/release overhead\n</code></pre> <p>The overhead is typically negligible, but for very high-frequency access patterns, it can add up.</p>"},{"location":"user-guide/thread-safety/#caching-reduces-overhead","title":"Caching Reduces Overhead","text":"<p>Objects are only instantiated once, so locking only happens on first access:</p> <pre><code>wired = Wiring(spec, thread_safe=True)\n\n# First access: pays locking overhead\nobj1 = wired.my_object()\n\n# Subsequent accesses: instant, no locking needed\nobj2 = wired.my_object()  # Cached!\n</code></pre>"},{"location":"user-guide/thread-safety/#real-world-example-multi-threaded-web-server","title":"Real-World Example: Multi-Threaded Web Server","text":"<pre><code>from concurrent.futures import ThreadPoolExecutor\nfrom apywire import Wiring\n\nspec = {\n    \"database_url\": \"postgresql://localhost/mydb\",\n    \"psycopg2.pool.ThreadedConnectionPool pool\": {\n        \"minconn\": 1,\n        \"maxconn\": 20,\n        \"dsn\": \"{database_url}\",\n    },\n}\n\n# Create thread-safe wiring container\nwired = Wiring(spec, thread_safe=True)\n\ndef handle_request(request_id):\n    \"\"\"Simulate handling a web request.\"\"\"\n    # Each thread safely accesses the connection pool\n    pool = wired.pool()\n    conn = pool.getconn()\n\n    # Use connection...\n    print(f\"Request {request_id} using connection\")\n\n    pool.putconn(conn)\n\n# Simulate multiple concurrent requests\nwith ThreadPoolExecutor(max_workers=10) as executor:\n    futures = [executor.submit(handle_request, i) for i in range(100)]\n    for future in futures:\n        future.result()\n</code></pre>"},{"location":"user-guide/thread-safety/#combining-with-async","title":"Combining with Async","text":"<p>You can combine thread safety with async access:</p> <pre><code>import asyncio\nfrom apywire import Wiring\n\nwired = Wiring(spec, thread_safe=True)\n\nasync def main():\n    # Thread-safe async access\n    obj = await wired.aio.my_object()\n</code></pre> <p>This is useful when:</p> <ul> <li>Running multiple event loops in different threads</li> <li>Mixing sync threaded code with async code</li> </ul>"},{"location":"user-guide/thread-safety/#compiling-with-thread-safety","title":"Compiling with Thread Safety","text":"<p>Generate thread-safe compiled code:</p> <pre><code>from apywire import WiringCompiler\n\ncompiler = WiringCompiler(spec)\ncode = compiler.compile(thread_safe=True)\n</code></pre> <p>The generated code will include the same two-level locking mechanism.</p>"},{"location":"user-guide/thread-safety/#thread-local-state","title":"Thread-Local State","text":"<p>apywire uses thread-local storage to track the resolution stack for circular dependency detection:</p> <pre><code># Under the hood\nimport threading\n\nclass _ThreadLocalState(threading.local):\n    def __init__(self):\n        self.resolving: list[str] = []\n</code></pre> <p>This ensures circular dependency detection works correctly across threads without interference.</p>"},{"location":"user-guide/thread-safety/#testing-thread-safety","title":"Testing Thread Safety","text":""},{"location":"user-guide/thread-safety/#test-for-race-conditions","title":"Test for Race Conditions","text":"<pre><code>import threading\nfrom apywire import Wiring\n\nspec = {\n    \"MyCounter counter\": {},\n}\n\nwired = Wiring(spec, thread_safe=True)\n\nresults = []\n\ndef worker():\n    obj = wired.counter()\n    results.append(id(obj))  # Store object id\n\nthreads = [threading.Thread(target=worker) for _ in range(100)]\n\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n\n# All threads should get the same object\nassert len(set(results)) == 1, \"Race condition detected!\"\n</code></pre>"},{"location":"user-guide/thread-safety/#test-for-deadlocks","title":"Test for Deadlocks","text":"<pre><code>def test_no_deadlock():\n    spec = {\n        \"MyClass obj\": {},\n    }\n\n    wired = Wiring(spec, thread_safe=True, max_lock_attempts=5)\n\n    def worker():\n        for _ in range(100):\n            _ = wired.obj()\n\n    threads = [threading.Thread(target=worker) for _ in range(10)]\n\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()  # Should complete without hanging\n</code></pre>"},{"location":"user-guide/thread-safety/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/thread-safety/#1-enable-thread-safety-only-when-needed","title":"1. Enable Thread Safety Only When Needed","text":"<pre><code># Development (single-threaded)\nwired = Wiring(spec, thread_safe=False)\n\n# Production (multi-threaded)\nimport os\nthread_safe = os.getenv(\"MULTI_THREADED\", \"false\") == \"true\"\nwired = Wiring(spec, thread_safe=thread_safe)\n</code></pre>"},{"location":"user-guide/thread-safety/#2-test-with-realistic-concurrency","title":"2. Test with Realistic Concurrency","text":"<pre><code># Test with actual thread count you'll use in production\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef test_with_realistic_concurrency():\n    wired = Wiring(spec, thread_safe=True)\n\n    with ThreadPoolExecutor(max_workers=20) as executor:  # Match prod\n        futures = [executor.submit(wired.my_object) for _ in range(1000)]\n        for future in futures:\n            future.result()\n</code></pre>"},{"location":"user-guide/thread-safety/#3-tune-lock-parameters-for-your-use-case","title":"3. Tune Lock Parameters for Your Use Case","text":"<pre><code># High contention: increase retries\nwired = Wiring(spec, thread_safe=True, max_lock_attempts=50)\n\n# Low contention: decrease sleep time\nwired = Wiring(spec, thread_safe=True, lock_retry_sleep=0.001)\n</code></pre>"},{"location":"user-guide/thread-safety/#4-monitor-for-lockunavailableerror","title":"4. Monitor for LockUnavailableError","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    obj = wired.my_object()\nexcept LockUnavailableError:\n    logger.error(\"Lock contention too high - consider increasing max_lock_attempts\")\n    raise\n</code></pre>"},{"location":"user-guide/thread-safety/#advanced-understanding-the-lock-mechanism","title":"Advanced: Understanding the Lock Mechanism","text":"<p>The locking implementation uses:</p> <ol> <li>Per-attribute locks: <code>dict[str, threading.Lock]</code> - one lock per wired attribute</li> <li>Global lock: Single <code>threading.Lock</code> for fallback</li> <li>Thread-local state: <code>threading.local()</code> for circular dependency tracking</li> </ol> <pre><code># Simplified pseudocode\ndef __getattr__(self, name: str):\n    if name in self._values:\n        return self._values[name]  # Already cached\n\n    # Try optimistic lock\n    attr_lock = self._attr_locks.get(name)\n    if attr_lock.acquire(blocking=False):\n        try:\n            obj = self._instantiate(name)\n            self._values[name] = obj\n            return obj\n        finally:\n            attr_lock.release()\n\n    # Fall back to global lock with retries\n    for attempt in range(self._max_lock_attempts):\n        if self._global_lock.acquire(blocking=False):\n            try:\n                obj = self._instantiate(name)\n                self._values[name] = obj\n                return obj\n            finally:\n                self._global_lock.release()\n        time.sleep(self._lock_retry_sleep)\n\n    raise LockUnavailableError(f\"Could not acquire lock for {name}\")\n</code></pre>"},{"location":"user-guide/thread-safety/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - Learn about non-thread-safe usage</li> <li>Async Support - Combine with async patterns</li> <li>Compilation - Generate thread-safe compiled code</li> </ul>"}]}